<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[挨踢夜归人]]></title>
  <link href="http://blog.loudou.info/atom.xml" rel="self"/>
  <link href="http://blog.loudou.info/"/>
  <updated>2015-01-13T10:48:26+08:00</updated>
  <id>http://blog.loudou.info/</id>
  <author>
    <name><![CDATA[_漏斗]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python 元类 DEF]]></title>
    <link href="http://blog.loudou.info/blog/2015/01/12/python-yuan-lei-def/"/>
    <updated>2015-01-12T20:13:16+08:00</updated>
    <id>http://blog.loudou.info/blog/2015/01/12/python-yuan-lei-def</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">元类基础</a></li>
  <li><a href="#section-1">2.* 和 3.* 的坑</a>    <ul>
      <li><a href="#section-2">兼容写法</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">元类基础</h2>

<p>Python 中一切事物都是类型的实例. </p>

<p>数值是数字类型的实例, 字符串是字符串类型的实例, 对象是类-类型的实例</p>

<p>同样的, 类(就是那个用 <code>class</code> 关键字创造出来的东西), 也是<em>某种</em>类型的实例</p>

<p>这种类型就叫<code>元类</code>.</p>

<p>如果说类是创建对象的模板, 那么<code>元类</code>就是创建类的模板</p>

<p>下面的代码就创建了一个名为 <code>meta</code> 的元类, 当然, 这个元类什么都没定义</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">meta</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s">&#39;meta&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="p">{})</span>
</span></code></pre></div></figure></notextile></div>

<p>当然, 元类的定义还有其它方法, 还请自行 <a href="https://mygso.herokuapp.com/search?q=Python+%E5%85%83%E7%B1%BB">Google</a></p>

<h2 id="section-1">2.* 和 3.* 的坑</h2>

<p>因为元类可能复用, 而要创建的类也会有一些自己的属性.</p>

<p>所以我们一般会这么写</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Cls</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">meta</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">method_of_cls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">pass</span>
</span></code></pre></div></figure></notextile></div>

<p>但是这么写有一个问题 – <code>不兼容 3.*</code></p>

<p>在 <code>3.*</code> 中, 元类语法不是上面这个样子</p>

<p>而是:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Cls</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">meta</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">method_of_cls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">pass</span>
</span></code></pre></div></figure></notextile></div>

<p>而且, 两种写法完全不兼容(不像 print)</p>

<h3 id="section-2">兼容写法</h3>

<p>语法上不兼容就没撤了?</p>

<p>如果真要兼容 <code>2.*</code> 和 <code>3.*</code>, 只能放弃 <code>class</code> 关键字, 直接使用 type 的返回值</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">Cls</span> <span class="o">=</span> <span class="n">meta</span>
</span></code></pre></div></figure></notextile></div>

<p>有需要自定义的方法的情况, 将 type 的调用封装一下就可以了.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">meta</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
</span><span class="line">    <span class="c"># do sth with name/parents/attrs</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">Cls</span> <span class="o">=</span> <span class="n">meta</span><span class="p">(</span><span class="s">&#39;Cls1&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="p">{})</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">method_of_cls2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">    <span class="k">pass</span>
</span><span class="line"><span class="n">Clas</span> <span class="o">=</span> <span class="n">meta</span><span class="p">(</span><span class="s">&#39;Cls2&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="p">{</span><span class="s">&#39;method_of_cls2&#39;</span><span class="p">:</span> <span class="n">method_of_cls2</span><span class="p">})</span>
</span></code></pre></div></figure></notextile></div>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BYE 2014]]></title>
    <link href="http://blog.loudou.info/blog/2014/12/31/bye-2014/"/>
    <updated>2014-12-31T15:14:19+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/12/31/bye-2014</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">2014再见</a>    <ul>
      <li><a href="#section-1">搬砖</a></li>
      <li><a href="#section-6">口琴</a></li>
      <li><a href="#mooc">MOOC</a></li>
      <li><a href="#section-7">败物</a></li>
      <li><a href="#section-8">逗[哔]生活</a></li>
    </ul>
  </li>
  <li><a href="#section-9">2015你好</a></li>
</ul>

<h2 id="section">2014再见</h2>

<h3 id="section-1">搬砖</h3>

<h4 id="linux-">Linux 才是真爱</h4>

<p>没啥好说的</p>

<p>Linux 才是真爱. 终端才是真爱</p>

<h4 id="section-2">工具转换</h4>

<p>大概分三步</p>

<ul>
  <li>商业工具 LR: 方便好用, 报表美得很</li>
  <li>开源工具 Jmeter + shell: 经济实惠, 集成美得很</li>
  <li>懂原理了, 自己写工具: 妈蛋, 要多少坑有多少坑</li>
</ul>

<h4 id="section-3">玩了不少语言</h4>

<p>基本都是浅尝辄止, 最后还是用 Python</p>

<ul>
  <li>nodejs, 重新看 OO</li>
  <li>ruby, 嗯~ 语法上和 Python 相近, 但更灵活</li>
  <li>Java, 静态语言必须死</li>
  <li>Io, 卧槽, 这尼玛也可以</li>
</ul>

<h4 id="section-4">技术活动</h4>

<p>参加了下面两个技术活动</p>

<ul>
  <li>MongoDB北京2014大会</li>
  <li>SegmentFault D-Day</li>
</ul>

<p>技术活动也不是每次都有足够的干货.</p>

<p>没事的时候去听听也无妨</p>

<h4 id="section-5">一个开源项目</h4>

<p><a href="https://github.com/Ralph-Wang/should">should</a></p>

<p>把 travis + coveralls 用上. 集成测试/版本测试真心不是问题</p>

<p>单元测试真心好用. 大刀阔斧上重构, 单元测试过就 ok.</p>

<p>=,= 没人一起玩就自己给自己报 Bug, 再自己改 Bug. 反正还有一个挂着</p>

<p>代码烂得一[哔]</p>

<p>正在进行重写式重构.</p>

<h3 id="section-6">口琴</h3>

<p>妈蛋, 这是年初目标之一. 结果到 11 月才开始搞.</p>

<p>而且到现在还是一个单音都吹不好的逗[哔]</p>

<h3 id="mooc">MOOC</h3>

<p>跟了不少课.</p>

<p>但只完成了一门.</p>

<h3 id="section-7">败物</h3>

<p>懒人不拍照</p>

<ul>
  <li>MBP – 真TM贵, 真TM好用.</li>
  <li>HHKB – 嗯, 机械盘退烧了</li>
  <li>iPod Touch – 不能打电话的肾</li>
  <li>肾6 – 好大</li>
  <li>iQunix – 帅, 有[哔]格</li>
</ul>

<h3 id="section-8">逗[哔]生活</h3>

<p>就一个关键词: 十万个冷笑话</p>

<ul>
  <li>首映时间发布会 - 全场节操满地, 福利满载, 寒舞满座</li>
  <li>舞台剧 - 高还原, 笑到不行…妈蛋, 原作+主创声优都在现场, 为毛没带大师球</li>
  <li>大电影 - 咦, 电影里居然有我</li>
</ul>

<p>反正节操是透支了, 也不打算还了…</p>

<h2 id="section-9">2015你好</h2>

<ul>
  <li>
    <p>嗯, 把 should 搞好点吧.. 没人用也要做好啊喂</p>
  </li>
  <li>
    <p>多留点时间来读书啊喂. 2014 你根本就没读几本书啊</p>
  </li>
  <li>
    <p>其实…今年有那么几个月, 我觉得已经在 2015了.</p>
  </li>
</ul>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 名称空间对性能的影响]]></title>
    <link href="http://blog.loudou.info/blog/2014/11/13/python-ming-cheng-kong-jian-dui-xing-neng-de-ying-xiang/"/>
    <updated>2014-11-13T20:03:05+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/11/13/python-ming-cheng-kong-jian-dui-xing-neng-de-ying-xiang</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">名称空间</a></li>
  <li><a href="#section-1">变量寻址</a></li>
  <li><a href="#section-2">循环优化</a></li>
</ul>

<h2 id="section">名称空间</h2>

<p>Python 中变量的作用域有一个特别的名字叫做<code>名称空间</code></p>

<p><code>名称空间</code>呢, 有以下这些特点:</p>

<ul>
  <li>每一个模块, 函数, 类, 实例, 都拥有一个独立的名称空间.    </li>
  <li>每一个变量都会处在一个名称空间下.     </li>
  <li>名称空间可以相互包含, 或者说有上下级关系</li>
  <li>在下级名称空间中可以访问上级名称空间的变量</li>
</ul>

<p>用代码来举例子:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>namespace.py</span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">in_module</span> <span class="o">=</span> <span class="s">&#39;in module&#39;</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">method</span><span class="p">():</span>
</span><span class="line">    <span class="n">in_method</span> <span class="o">=</span> <span class="s">&#39;in method&#39;</span>
</span></code></pre></div></figure></notextile></div>

<p>在上面这段代码中, 一共有 个名称空间, 分别是:</p>

<ul>
  <li>文件, 就是 <code>namespace.py</code> 里面, 有<code>in_module</code> 变量</li>
  <li>函数, 就是 <code>method</code> 里面, 有<code>in_method</code> 变量</li>
</ul>

<p>以上名称空间, 从上向下都是包含关系.</p>

<h2 id="section-1">变量寻址</h2>

<p>一般来讲, 在一个名称空间中, 只能访问到属于这个名称空间的变量</p>

<p>所以对于上面的代码来讲:</p>

<table>
  <thead>
    <tr>
      <th>名称空间</th>
      <th>可见变量</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>namespace.py</td>
      <td><code>in_module</code></td>
    </tr>
    <tr>
      <td>method</td>
      <td><code>in_method</code></td>
    </tr>
  </tbody>
</table>

<p>同时, 下级名称空间是可以访问到上级名称空间中的变量的.  <br />
于是上表就变成了</p>

<table>
  <thead>
    <tr>
      <th>名称空间</th>
      <th>可见变量</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>namespace.py</td>
      <td><code>in_module</code></td>
    </tr>
    <tr>
      <td>method</td>
      <td><code>in_method</code>, <code>in_module</code></td>
    </tr>
  </tbody>
</table>

<p>所以现在可以在 <code>method</code> 中访问所有 <code>in_*</code> 变量  <br />
就像下面这样</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">method</span><span class="p">():</span>
</span><span class="line">    <span class="n">in_method</span> <span class="o">=</span> <span class="s">&#39;in method&#39;</span>
</span><span class="line">    <span class="k">print</span> <span class="n">in_method</span>
</span><span class="line">    <span class="k">print</span> <span class="n">in_module</span>
</span></code></pre></div></figure></notextile></div>

<p>所谓<code>变量寻址</code>, 指的就是</p>

<blockquote>
  <p>Python 在当前名称空间下找不到变量定义时,
会继续搜索上一层名称空间, 直到顶层.</p>
</blockquote>

<p>这件事了.</p>

<p>概念说了一大堆, 和性能优化好像都没啥关系. 下面就进入正题</p>

<h2 id="section-2">循环优化</h2>

<p>在日常代码编写中, 我们有时会写类似这样的代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="kn">import</span> <span class="nn">math</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span>
</span><span class="line">        <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></code></pre></div></figure></notextile></div>

<p>上面代码中, <code>foo</code> 里并没有定义 <code>math</code>.
它是通过<code>变量寻址</code>在上一层找到了引入进来的<code>math</code>进行操作</p>

<p>并且, 在循环内部, 每访问一次 <code>math</code> 就会发生一次<code>变量寻址</code>.
这对性能有一定的损耗.</p>

<p>我们可以创建一个<code>foo</code>内部的变量直接指向我们要用的<code>math.sin</code>
然后再进入循环, 这样可以节省不少时间</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">woo</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">    <span class="n">sin</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span>
</span><span class="line">        <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></code></pre></div></figure></notextile></div>

<p>当然, 类似这样重复调用外部方法的函数, 我们可以直接用 <code>map</code> 来代替</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">moo</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span>
</span></code></pre></div></figure></notextile></div>

<p>下面是用 <code>timeit</code> 模块跑的基准测试结果:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">foo</span><span class="p">:</span> <span class="mf">20.8992490768</span>
</span><span class="line"><span class="n">woo</span><span class="p">:</span> <span class="mf">15.5716171265</span>
</span><span class="line"><span class="n">moo</span><span class="p">:</span> <span class="mf">12.033983945</span>
</span></code></pre></div></figure></notextile></div>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BASH 特别的 Patch 技巧]]></title>
    <link href="http://blog.loudou.info/blog/2014/10/18/bash-te-bie-de-patch-ji-qiao/"/>
    <updated>2014-10-18T21:43:24+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/10/18/bash-te-bie-de-patch-ji-qiao</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">问题</a></li>
  <li><a href="#section-1">解决方案</a></li>
  <li><a href="#section-2">相关工具</a></li>
</ul>

<h2 id="section">问题</h2>

<p>9 月底爆出的 bash 漏洞, Mac 自然也受到影响.</p>

<p>但当时并没有找到苹果官方的解决方案,  <br />
而 bash 官方释出的补丁方式完全看不懂怎么用…  <br />
再加上就快升级 10.10 了.</p>

<p>想着也许会在升级时把补丁打上呢.  <br />
(呃, 其实是懒得研究官方补丁怎么用)  <br />
也就放着没管了</p>

<p>但昨天升级完后, 却发现并没有打上补丁.</p>

<p>只好硬着头皮上了.</p>

<h2 id="section-1">解决方案<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2>

<p>因为官方的补丁都是打在源码上的,  <br />
所以我们需要去 <a href="http://ftp.gnu.org/gnu/bash/">http://ftp.gnu.org/gnu/bash/</a> 下载 bash 的源码</p>

<p>没什么特别的需求的话, 就直接选最新的 4.3 版本好了. 懒人点 <a href="http://ftp.gnu.org/gnu/bash/bash-4.3.tar.gz">这里</a></p>

<p>下载完成后直接解压即可</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$ </span>tar zxvf bash-4.3.tar.gz
</span></code></pre></div></figure></notextile></div>

<p>现在不着急编译安装, 因为我们还需要在源码上打补丁.</p>

<p>我们需要到 <a href="http://ftp.gnu.org/gnu/bash/bash-4.3-patches/">bash-4.3-patches</a> 目录下把 01~30 补丁全部下载下来.</p>

<p>因为不想一个一个点, 所以玩了点小花样:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$ </span>seq -f %02g 30| xargs -Ix curl -O &lt;path-of-patches&gt;/bash43-0x
</span></code></pre></div></figure></notextile></div>

<p>好了, 把下载好的这些个补丁放到 bash 的源码目录下. 用 patch “一个一个”把补丁打上吧.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$ </span><span class="k">for </span>i in <span class="sb">`</span>seq -f %02g 30<span class="sb">`</span>; <span class="k">do </span>patch -p0 &lt; bash43-0<span class="nv">$i</span>;<span class="k">done</span>
</span></code></pre></div></figure></notextile></div>

<blockquote>
  <p>这里因为变量在重定向符后面, 所以不能用 xargs 进行</p>
</blockquote>

<p>好了, 接下来就是编译安装 -&gt; 替换原有 bash, 就好了</p>

<h2 id="section-2">相关工具</h2>

<p>patch: <a href="http://blog.chinaunix.net/uid-9525959-id-2001542.html">这里</a>有一篇文章讲得蛮详细的, 就不重新造轮子了.</p>

<p>两个 bug 的测试代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">env <span class="nv">x</span><span class="o">=</span><span class="s1">&#39;() { :;}; echo Your bash is Fucked&#39;</span>  bash -c <span class="s2">&quot;echo just test&quot;</span>
</span></code></pre></div></figure></notextile></div>

<p>没漏洞的 bash 是不会被 Fuck 的</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">env <span class="nv">X</span><span class="o">=</span><span class="err">&#39;</span><span class="o">()</span> <span class="o">{</span> <span class="o">(</span>a<span class="o">)=</span>&gt;<span class="se">\&#39;</span> bash -c <span class="s2">&quot;echo date&quot;</span>; cat <span class="nb">echo</span><span class="o">}</span>
</span></code></pre></div></figure></notextile></div>

<p>没漏洞的 bash 看到的是 date 字样.</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>因为是用官方源码打补丁, 所以 *NIX 系统通用<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[count += 1 不是原子级的]]></title>
    <link href="http://blog.loudou.info/blog/2014/10/10/count-plus-equals-1-bu-shi-yuan-zi-ji-de/"/>
    <updated>2014-10-10T12:04:09+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/10/10/count-plus-equals-1-bu-shi-yuan-zi-ji-de</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">怀疑</a></li>
  <li><a href="#section-1">测试</a></li>
  <li><a href="#section-2">分析</a></li>
  <li><a href="#section-3">扩展</a></li>
</ul>

<h2 id="section">怀疑</h2>

<p>一直以为 Python 中类似 <code>count += 1</code> 的操作是原子级的…</p>

<p>于是在看到如下代码时, 产生了怀疑</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">done_num</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line"><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
</span><span class="line"><span class="c"># 省略...</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Trans</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">global</span> <span class="n">count</span>
</span><span class="line">        <span class="c"># ...</span>
</span><span class="line">        <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
</span><span class="line">        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class="line">        <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</span><span class="line">        <span class="c"># ...</span>
</span></code></pre></div></figure></notextile></div>

<p>看到这部分代码时, 第一反应是为毛这种统计要用全局变量做啊…  <br />
且不说这种用全局变量的行为; 为毛做个计数 + 1 也要锁一下啊. 难道计数不是原子级的吗!!!</p>

<h2 id="section-1">测试</h2>

<p>本着, <code>如果不出代码出过问题, 不会在这么逗[哔][^1]的地方加锁</code> 的想法. 用以下代码进行了测试.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">GlobalCount</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="nb">super</span><span class="p">(</span><span class="n">GlobalCount</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">global</span> <span class="n">count</span>
</span><span class="line">        <span class="k">for</span> <span class="n">dummy_i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
</span><span class="line">            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line"><span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line"><span class="n">threads_num</span> <span class="o">=</span> <span class="mi">100000</span>
</span><span class="line">
</span><span class="line"><span class="k">for</span> <span class="n">dummy_i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">threads_num</span><span class="p">):</span>
</span><span class="line">    <span class="n">threads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">GlobalCount</span><span class="p">())</span>
</span><span class="line">
</span><span class="line"><span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
</span><span class="line">    <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
</span><span class="line">    <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="k">print</span> <span class="n">count</span>
</span></code></pre></div></figure></notextile></div>

<p>如果 count += 1 是线程安全的话, 上面这段脚本执行完成后输出应该是 <code>1000000</code>. 不会多, 也不会少</p>

<p>执行以上脚本三次的结果:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">999990
</span><span class="line">999982
</span><span class="line">999940
</span></code></pre></div></figure></notextile></div>

<p>哇嚓嘞, 还真是线程不安全的…</p>

<h2 id="section-2">分析</h2>

<p>好吧, 即然线程不安全了, 那为什么呢? 为什么做个加法会线程不安全呢?</p>

<p>来看下 <code>count += 1</code> 的编译码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">3 LOAD_CONST               1 <span class="o">(</span>1<span class="o">)</span>
</span><span class="line">6 INPLACE_ADD
</span><span class="line">7 STORE_GLOBAL             0 <span class="o">(</span>count<span class="o">)</span>
</span></code></pre></div></figure></notextile></div>

<p>假设如下场景:  <br />
1. 如果有那个一个线程完成 <code>3 LOAD_CONST</code> 后, 因为时间片消耗完了停了一小会儿. 我们假设这时 count 为 999  <br />
2. 这时候, 其它线程正常进行, 并且 count 已经增加到 1003 或者更大.  <br />
3. <code>1.</code>中的线程又得到的时间片, 完成后续步骤. 这时 count 被改回到 1000.  <br />
4. 其它线程的计数被抹掉了…</p>

<h2 id="section-3">扩展</h2>

<p>类似的在其它语言中 <code>count++</code> 等操作也有不是线程安全的</p>

<p>相关阅读: <a href="https://www.google.com/?gws_rd=ssl#q=i%2B%2B+%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">来自Google</a></p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BASH 中 的正则表达式(误)]]></title>
    <link href="http://blog.loudou.info/blog/2014/10/09/bash-zhong-de-zheng-ze-biao-da-shi-wu/"/>
    <updated>2014-10-09T14:45:30+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/10/09/bash-zhong-de-zheng-ze-biao-da-shi-wu</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">源</a></li>
  <li><a href="#section-1">思考</a></li>
  <li><a href="#section-2">总结</a></li>
</ul>

<h2 id="section">源</h2>

<p>今天在写一个 bash 脚本时, 有一部分需要判断 ip 的格式.  <br />
这样的功能自然就想到了高大上的<code>正则表达式</code>同学.</p>

<p>但记得 bash 并不直接支持正则表达式. 于是用 <code>sed</code> 实现了这个功能.</p>

<p>不过, 因为好奇大牛们是怎么处理类似问题的, 仍然去搜索了一下.</p>

<p>发现原来 bash 也支持正则表达式(误).   <br />
大概说法是这样的. 在 <code>[[ ]]</code> 中写正则就可以了. 下面是一个例子</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">1</span> <span class="o">=</span>~ <span class="o">[</span>0-9<span class="o">]</span> <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span></code></pre></div></figure></notextile></div>

<p>于是用这种方式, 完成了最初那个 ip 格式判断的需求…</p>

<p>好吧, 我承认是直接抄这里的: <a href="http://openwares.net/linux/bash_regex_ip_port.html">BASH脚本中使用正则表达式检查IP地址和端口号</a></p>

<blockquote>
  <p>PS. 测试过 255.255.255.256 这样的 ip 是不通过的 : )</p>
</blockquote>

<h2 id="section-1">思考</h2>

<p>一般来说, 需求完成了. 我们就可以收工了.  <br />
但本着逗[哔]的探究精神, 对 <code>[[ ]]</code> 做了如下测试</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">1</span> <span class="o">=</span> <span class="o">[</span>0-9<span class="o">]</span> <span class="o">]]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span></code></pre></div></figure></notextile></div>

<p>结果输出: 0.</p>

<p>哇嚓, 所以 <code>=</code> 就可以了吗? 那 <code>=~</code> 是用来干嘛的???</p>

<p>正则的话, 除了 match 还有 search 方式.  <br />
Ok, 测试下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">abc123ddd</span> <span class="o">=</span> <span class="o">[</span>0-9<span class="o">]</span> <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">abc123ddd</span> <span class="o">=</span>~ <span class="o">[</span>0-9<span class="o">]</span> <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span></code></pre></div></figure></notextile></div>

<p>第一行无输出, 第二行输出: 0.</p>

<p>明了: <code>=</code> 是完全匹配, 即 match; <code>=~</code> 部分匹配, 即 search</p>

<p>好了, 再来试一下其它元字符</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">12</span> <span class="o">=</span> <span class="o">[</span>0-9<span class="o">]</span>. <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span></code></pre></div></figure></notextile></div>

<p>没结果输出</p>

<p>哇嚓, 这又是怎么回事…</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">12</span> <span class="o">=</span> <span class="o">[</span>0-9<span class="o">]</span>* <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span></code></pre></div></figure></notextile></div>

<p>输出: 0.</p>

<p>难道…</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">12</span> <span class="o">=</span> ?? <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">12</span> <span class="o">=</span> * <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span></code></pre></div></figure></notextile></div>

<p>以上两行均有输出.</p>

<p>原来如此, <code>[[ ]]</code> 并不支持正则表达式.
它所支持的是 <code>glob</code> 表达式, 也就是我们常说的 <code>通配符</code></p>

<h2 id="section-2">总结</h2>

<p>探索结束. 总结一下</p>

<ol>
  <li><code>[[ expression ]]</code> 并不支持正则表达式, 其支持的是 <code>glob</code> 表达式</li>
  <li><code>[[ ]]</code> 中可以用 <code>=</code> 表达匹配, 要示左侧字符串和右侧 <code>glob</code> 完全匹配</li>
  <li>也可以使用 <code>=~</code> 进行搜索, 只要左侧字符串有部分与右侧匹配即可</li>
</ol>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python 中的三元运算符]]></title>
    <link href="http://blog.loudou.info/blog/2014/09/05/python-zhong-de-san-yuan-yun-suan-fu/"/>
    <updated>2014-09-05T11:08:30+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/09/05/python-zhong-de-san-yuan-yun-suan-fu</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">方法介绍</a>    <ul>
      <li><a href="#if-1">IF 块</a></li>
      <li><a href="#section-1">逻辑运算</a></li>
      <li><a href="#if">内联 IF</a></li>
    </ul>
  </li>
  <li><a href="#section-3">基准测试</a></li>
</ul>

<h2 id="section">方法介绍</h2>

<p>Python 原生是不支持三元运算符: <code>(expresion):val1?val2</code>  <br />
但 Python 提供了一些语法糖在模拟三元运算符的操作</p>

<p>就以下面这样一个用例来看看 Python 中可以怎么处理三元运算</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="c"><span class="line"><span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="mi">1</span><span class="o">:</span><span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">?-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span>
</span></code></pre></div></figure></notextile></div>

<p>运算含义: val 值为正则返回 1, 为负则返回 -1, 为 0 则返回 0</p>

<h3 id="if-1">IF 块<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h3>

<p>这个是最笨拙的方法. 用 <code>if...else...</code> 块实现</p>

<p>写出来后代码如下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">if_block</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
</span><span class="line">    <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">elif</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span><span class="line">    <span class="k">else</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">0</span>
</span></code></pre></div></figure></notextile></div>

<p>因为是直接用 <code>if...else...</code> 描述出三元描述符的运算过程.  <br />
所以这种实现方法是最容易理解的.</p>

<h3 id="section-1">逻辑运算</h3>

<p><code>IF 块</code> 的方法虽然很容易理解, 但是相对的代码行数略微多了点.</p>

<p>那能不能一行就搞定呢.  <br />
当然是可以的.</p>

<p>用<code>逻辑运算</code>来处理它</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">and_or</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
</span><span class="line">    <span class="k">return</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="mi">0</span>
</span></code></pre></div></figure></notextile></div>

<p>这种方法阅读起来并不是那么的直观, 但是三种方法中最接近原始表达.  <br />
其中<code>逻辑符号</code>和<code>运算符</code>对应关系如下表</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">逻辑符号</th>
      <th style="text-align: center">运算符号</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code>and</code></td>
      <td style="text-align: center"><code>?</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code>or</code></td>
      <td style="text-align: center"><code>:</code></td>
    </tr>
  </tbody>
</table>

<h4 id="section-2">不过…</h4>

<p>这种方法有一个缺点, <code>and</code> 后的值对应的布尔值必须为真.
像下面这个条件, 返回值总会是 -1</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">or</span> <span class="o">-</span><span class="mi">1</span>
</span></code></pre></div></figure></notextile></div>

<p>嘛, 毕竟它只是<code>逻辑运算</code></p>

<h3 id="if">内联 IF</h3>

<p>虽然用<code>逻辑运算</code>去 hack 是最接近三元运算最原始的表达的. 但毕竟有一个缺陷.</p>

<p>于是, 就是最后一种内联IF的写法. 很类似列表表达式</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">if_inline</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
</span></code></pre></div></figure></notextile></div>

<p>就可读性来说, 这种写法是比较差的, 但没有逻辑运算那样的缺陷.
同时, 也不像 block 版那样写三遍 return</p>

<h2 id="section-3">基准测试</h2>

<p>既然有三种不同的写法, 那三种写法的执行效率是否一样呢.</p>

<p>于是写了如下测试脚本:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ternary.py</span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">random</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">if_block</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
</span><span class="line">    <span class="s">&#39;use if block for ternary operation&#39;</span>
</span><span class="line">    <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">elif</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span><span class="line">    <span class="k">else</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">0</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">if_inline</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
</span><span class="line">    <span class="s">&#39;use if inline for ternary operation&#39;</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">and_or</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
</span><span class="line">    <span class="s">&#39;use and/or for ternary operation&#39;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="mi">0</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
</span><span class="line">    <span class="kn">import</span> <span class="nn">timeit</span>
</span><span class="line">    <span class="kn">import</span> <span class="nn">dis</span>
</span><span class="line">    <span class="k">print</span> <span class="s">&#39;if_block:&#39;</span>
</span><span class="line">    <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">if_block</span><span class="p">)</span>
</span><span class="line">    <span class="k">print</span> <span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s">&#39;if_block(random.randrange(-10,11))&#39;</span><span class="p">,</span>
</span><span class="line">                        <span class="s">&#39;from __main__ import if_block, random&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="k">print</span> <span class="s">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span>
</span><span class="line">
</span><span class="line">    <span class="k">print</span> <span class="s">&#39;if_inline:&#39;</span>
</span><span class="line">    <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">if_inline</span><span class="p">)</span>
</span><span class="line">    <span class="k">print</span> <span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s">&#39;if_inline(random.randrange(-10,11))&#39;</span><span class="p">,</span>
</span><span class="line">                        <span class="s">&#39;from __main__ import if_inline, random&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="k">print</span> <span class="s">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span>
</span><span class="line">
</span><span class="line">    <span class="k">print</span> <span class="s">&#39;and_or:&#39;</span>
</span><span class="line">    <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">and_or</span><span class="p">)</span>
</span><span class="line">    <span class="k">print</span> <span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s">&#39;and_or(random.randrange(-10,11))&#39;</span><span class="p">,</span>
</span><span class="line">                        <span class="s">&#39;from __main__ import and_or, random&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="k">print</span> <span class="s">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="n">test</span><span class="p">()</span>
</span></code></pre></div></figure></notextile></div>

<p>脚本执行结果如下:  <br />
可以很清楚的看到, 三种写法编译后的指令数是一样的.  <br />
执行时间相差也不大, 多次执行时会有一定浮动
(果然应该把 timeit 次数设置大一点么)</p>

<blockquote>
  <p><code>if_block</code> 最后多出来 2 条指令是因为 Python 中函数最后默认返回 None. 实际调用时, 不可能会执行到这两条指令</p>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="text"><span class="line">if_block:
</span><span class="line">  8           0 LOAD_FAST                0 (val)
</span><span class="line">              3 LOAD_CONST               1 (0)
</span><span class="line">              6 COMPARE_OP               4 (&gt;)
</span><span class="line">              9 POP_JUMP_IF_FALSE       16
</span><span class="line">
</span><span class="line">  9          12 LOAD_CONST               2 (1)
</span><span class="line">             15 RETURN_VALUE
</span><span class="line">
</span><span class="line"> 10     &gt;&gt;   16 LOAD_FAST                0 (val)
</span><span class="line">             19 LOAD_CONST               1 (0)
</span><span class="line">             22 COMPARE_OP               0 (&lt;)
</span><span class="line">             25 POP_JUMP_IF_FALSE       32
</span><span class="line">
</span><span class="line"> 11          28 LOAD_CONST               3 (-1)
</span><span class="line">             31 RETURN_VALUE
</span><span class="line">
</span><span class="line"> 13     &gt;&gt;   32 LOAD_CONST               1 (0)
</span><span class="line">             35 RETURN_VALUE
</span><span class="line">             36 LOAD_CONST               4 (None)
</span><span class="line">             39 RETURN_VALUE
</span><span class="line">1.25232696533
</span><span class="line">--------------------
</span><span class="line">if_inline:
</span><span class="line"> 18           0 LOAD_FAST                0 (val)
</span><span class="line">              3 LOAD_CONST               1 (0)
</span><span class="line">              6 COMPARE_OP               4 (&gt;)
</span><span class="line">              9 POP_JUMP_IF_FALSE       16
</span><span class="line">             12 LOAD_CONST               2 (1)
</span><span class="line">             15 RETURN_VALUE
</span><span class="line">        &gt;&gt;   16 LOAD_FAST                0 (val)
</span><span class="line">             19 LOAD_CONST               1 (0)
</span><span class="line">             22 COMPARE_OP               0 (&lt;)
</span><span class="line">             25 POP_JUMP_IF_FALSE       32
</span><span class="line">             28 LOAD_CONST               3 (-1)
</span><span class="line">             31 RETURN_VALUE
</span><span class="line">        &gt;&gt;   32 LOAD_CONST               1 (0)
</span><span class="line">             35 RETURN_VALUE
</span><span class="line">1.26190900803
</span><span class="line">--------------------
</span><span class="line">and_or:
</span><span class="line"> 23           0 LOAD_FAST                0 (val)
</span><span class="line">              3 LOAD_CONST               1 (0)
</span><span class="line">              6 COMPARE_OP               4 (&gt;)
</span><span class="line">              9 POP_JUMP_IF_FALSE       18
</span><span class="line">             12 LOAD_CONST               2 (1)
</span><span class="line">             15 JUMP_IF_TRUE_OR_POP     39
</span><span class="line">        &gt;&gt;   18 LOAD_FAST                0 (val)
</span><span class="line">             21 LOAD_CONST               1 (0)
</span><span class="line">             24 COMPARE_OP               0 (&lt;)
</span><span class="line">             27 POP_JUMP_IF_FALSE       36
</span><span class="line">             30 LOAD_CONST               3 (-1)
</span><span class="line">             33 JUMP_IF_TRUE_OR_POP     39
</span><span class="line">        &gt;&gt;   36 LOAD_CONST               1 (0)
</span><span class="line">        &gt;&gt;   39 RETURN_VALUE
</span><span class="line">1.27082109451
</span><span class="line">--------------------
</span></code></pre></div></figure></notextile></div>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>这三个名称都不是官方名称…<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[blockdev 命令及相关概念]]></title>
    <link href="http://blog.loudou.info/blog/2014/08/20/blockdev-ming-ling-ji-xiang-guan-gai-nian/"/>
    <updated>2014-08-20T23:36:02+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/08/20/blockdev-ming-ling-ji-xiang-guan-gai-nian</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section">命令本身</a></li>
  <li><a href="#report-">report 的内容</a></li>
</ul>

<h2 id="section">命令本身</h2>

<p><code>blockdev</code> 是直接调用 <code>ioctl</code> 函数的一个命令.</p>

<p>其原生帮助如下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$ </span>blockdev
</span><span class="line">
</span><span class="line">用法:
</span><span class="line">  blockdev -V
</span><span class="line">  blockdev --report <span class="o">[</span>devices<span class="o">]</span>
</span><span class="line">  blockdev <span class="o">[</span>-v|-q<span class="o">]</span> commands devices
</span><span class="line">
</span><span class="line">可用命令:
</span><span class="line">    <span class="c"># 这里暂时省略.</span>
</span></code></pre></div></figure></notextile></div>

<ul>
  <li><code>-V</code> 自然是查看版本号了, 这里就不多说    </li>
  <li><code>--report</code> 用来查看硬盘的相关配置参数, 不传硬盘的话, 会显示所有硬盘    </li>
  <li>最后一种用法, 就是调用各种命令, 对硬盘进行设置. 或单个参数的查看.</li>
</ul>

<h2 id="report-">report 的内容</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$ </span>blockdev --report
</span><span class="line">RO    RA    SSZ    BSZ    StartSec          Size    Device
</span><span class="line">rw   256    512   4096           0   21474836480    /dev/xvda
</span></code></pre></div></figure></notextile></div>

<p>调用 blockdev 时需要注意使用 <code>root</code> 用户, 或者 <code>sudo</code></p>

<p>现在来看一下这些字段都是些什么含义</p>

<table>
  <tbody>
    <tr>
      <td>字段</td>
      <td>全称</td>
      <td>含义</td>
    </tr>
    <tr>
      <td>RO</td>
      <td>readonly</td>
      <td>硬盘的读写状态. <code>rw</code> 表示可读可写, <code>ro</code> 则表示只读</td>
    </tr>
    <tr>
      <td>RA</td>
      <td>readahead</td>
      <td><code>预读</code> 的大小. Linux 实际大小为 readahead * 2 (KB)</td>
    </tr>
    <tr>
      <td>SSZ</td>
      <td>sector size</td>
      <td>Linux 中<code>扇区</code>(sector) 大小, 单位 <code>byte</code></td>
    </tr>
    <tr>
      <td>BSZ</td>
      <td>block size</td>
      <td>Linux 中<code>块</code>大小 , 单位 <code>byte</code></td>
    </tr>
    <tr>
      <td>StarcSec</td>
      <td>start sector</td>
      <td>当前设备是从第几个 sector 开始的</td>
    </tr>
    <tr>
      <td>Size</td>
      <td>…</td>
      <td>设备的大小, 不支持 -h 参数变得可读 Orz</td>
    </tr>
    <tr>
      <td>Device</td>
      <td>…</td>
      <td>硬盘对应的设备文件</td>
    </tr>
  </tbody>
</table>

<p>想必你现在和我一样, 表格里面的东西看得晕晕乎乎的.</p>

<p>下面我们简单说明一下</p>

<h4 id="section-1">预读</h4>

<p>当 Linux 向磁盘发起 IO 时, 会进行所谓的<code>预读</code>操作.
即, 会比 CPU 操作需要的内容多从读取一小块内容.</p>

<blockquote>
  <p>当然, 如果发现下一次 IO 是随机的, 便会中断当前预读</p>
</blockquote>

<p>而 <code>readahead</code> 项, 就是配置需要提前读取的内容大小</p>

<p>在 tuning<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 数据服务器, 需要关注这个参数  <br />
不过, 一般情况下, 使用默认的 256 (即预读 512KB) 就足够了.</p>

<h4 id="section-2">扇区</h4>

<p><code>扇区</code>是硬盘的物理属性. 也是操作系统读取数据的最小单位.</p>

<h4 id="section-3">块</h4>

<p><code>块</code> 是操作系统在存储文件时的最小单位. 不论文件真实大小, 其占据的硬盘空间一定是块的整数倍.</p>

<p>一个只有一个字符的文件却占据 4K 空间, 就是这个原因</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$ </span>cat txt
</span><span class="line">1
</span><span class="line"><span class="nv">$ </span>du -h txt
</span><span class="line">4.0K    txt
</span></code></pre></div></figure></notextile></div>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>不知道怎么翻译好… 有调优的意思, 但又有试探性<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux bash 的 C-s]]></title>
    <link href="http://blog.loudou.info/blog/2014/08/13/linux-bash-de-c-s/"/>
    <updated>2014-08-13T22:22:02+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/08/13/linux-bash-de-c-s</id>
    <content type="html"><![CDATA[<p>putty 莫名不响应问题…</p>

<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">事故</a></li>
  <li><a href="#emacs">缘起 emacs</a></li>
  <li><a href="#c-sc-q">C-s/C-q</a></li>
  <li><a href="#c-s-">取消 C-s 绑定</a></li>
</ul>

<h2 id="section">事故</h2>

<p>在 Windows 下, 一直使用 putty 作为连接远程 Linux 的工具.</p>

<p>偶尔会出现 putty 不响应的现象. 一直不知道是什么问题.  <br />
遇到了也就是重启一下 putty. 也就没有太理会它</p>

<p>今天一次逗[哔]的尝试, 却找到了这个问题的源头:</p>

<blockquote>
  <p>该死的 C-s</p>
</blockquote>

<h2 id="emacs">缘起 emacs</h2>

<p><code>emacs</code> 中 <code>C-s</code> 和 <code>C-r</code> 对应的<code>向下</code>搜索和<code>向上</code>搜索  <br />
而 <code>bash</code> 的编辑快捷键默认采用的便是 emacs 模式.  <br />
便试了试 <code>C-s</code>. 结果出现了不响应的情况.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>搜索到下<a href="http://tianya23.blog.51cto.com/1081650/740207">这篇文章</a></p>

<h2 id="c-sc-q">C-s/C-q</h2>

<p>bash 中 <code>C-s</code> 和 <code>C-q</code> 是代表了一对<code>流控制符</code>.  <br />
其作用就是<code>停止</code>和<code>重启</code>从一个设备向另一个设备的输出流.  <br />
以前是用来切断速率过低的传输过程的(具体有多低, 我也不知道)    </p>

<p>现在的网络比以往要快很多,  <br />
所以这两个控制符也就没什么大用了  <br />
只需要记住, 误敲 <code>C-s</code> 导致 bash 不响应时,    </p>

<blockquote>
  <p>敲下<code>C-q</code> 即可恢复    </p>
</blockquote>

<p>—2014-09-05—</p>

<h2 id="c-s-">取消 C-s 绑定</h2>

<p><code>stty stop undef</code></p>

<p>若要长期生效, 可以写到个人 profile 中</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>bash 中 <code>C-r</code> 仍是<code>向上</code>搜索. 不过,搜索目标是命令历史<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binary Tree Preorder Traversal]]></title>
    <link href="http://blog.loudou.info/blog/2014/08/07/binary-tree-preorder-traversal/"/>
    <updated>2014-08-07T00:50:19+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/08/07/binary-tree-preorder-traversal</id>
    <content type="html"><![CDATA[<p>算法倒是没犯错. 坑在 Python 的一个赋值语法上了</p>

<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">题目</a>    <ul>
      <li><a href="#section-1">翻译</a></li>
    </ul>
  </li>
  <li><a href="#section-2">我的解法</a>    <ul>
      <li><a href="#dsf">迭代式(DSF)</a></li>
      <li><a href="#section-3">递归式</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">题目</h2>

<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>

<p>For example: <br />
Given binary tree {1,#,2,3},</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><pre><code class=""><span class="line">   1
</span><span class="line">    \
</span><span class="line">     2
</span><span class="line">    /
</span><span class="line">   3</span></code></pre></div></figure></notextile></div>

<p>return [1,2,3].</p>

<p>Note: Recursive solution is trivial, could you do it iteratively?</p>

<h3 id="section-1">翻译</h3>

<p>一颗二叉树. 返回按前序遍历排序的节点值列表</p>

<p>例子:
二叉树: {1, #, 2, 3}</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><pre><code class=""><span class="line">   1
</span><span class="line">    \
</span><span class="line">     2
</span><span class="line">    /
</span><span class="line">   3</span></code></pre></div></figure></notextile></div>

<p>返回 [1, 2, 3]</p>

<p>注: 递归式相当简单.试试迭代式?</p>

<h2 id="section-2">我的解法</h2>

<h3 id="dsf">迭代式(DSF)</h3>

<p>最近正好在看图的遍历. 看了下二叉树前序遍历的定义. 自然就想到了用 DSF 算法.  <br />
很快就把代码写好了. 但得到的不是 RunTime Error, 就是 Time Limited Exceeded…</p>

<p>但是, 用 Java 实现却是直接就通过了…(忽略因为不熟 Java 各种类型造成的多次编译错误)</p>

<p>!!!! 还能不能愉快的玩耍了…n</p>

<p>把代码拷到本地调试后发现, 执行过程中 <code>discovered</code> 和 <code>ans</code> 是同一个列表  <br />
回头看我的初始化代码</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">discovered</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
</span></code></pre></div></figure></notextile></div>

<p>明白了…</p>

<p>Python 里面这样的连等赋值是将同一对象坑给不同变量…  <br />
因为以前这样赋值时多是<code>不变量</code>, 所以没什么问题.  <br />
但列表是<code>容器</code>, 所以..就出现了问题</p>

<p>修改初始化</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">discovered</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line"><span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
</span></code></pre></div></figure></notextile></div>

<p>OK, 顺利通过~  <br />
下面是完整代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span><span class="line">    <span class="c"># @param root, a tree node</span>
</span><span class="line">    <span class="c"># @return a list of integers</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
</span><span class="line">        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c"># empty tree</span>
</span><span class="line">            <span class="k">return</span> <span class="p">[]</span>
</span><span class="line">        <span class="n">discovered</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># error type: discovered = ans = []</span>
</span><span class="line">        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line">        <span class="n">discovered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</span><span class="line">        <span class="k">while</span> <span class="n">discovered</span> <span class="o">!=</span> <span class="p">[]:</span>
</span><span class="line">            <span class="n">v</span> <span class="o">=</span> <span class="n">discovered</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</span><span class="line">            <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</span><span class="line">            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
</span><span class="line">                <span class="n">discovered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</span><span class="line">            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
</span><span class="line">                <span class="n">discovered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ans</span>
</span></code></pre></div></figure></notextile></div>

<h3 id="section-3">递归式</h3>

<p>递归式也不是很难. 想清楚 Base Case 好了</p>

<ul>
  <li>Base Case: 以空树作为 Base Case, 返回空列表 <code>[]</code>    </li>
  <li>Recursion: 如果有的话, 依次加上左子树和右子树的前序列表就可以了</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span><span class="line">    <span class="c"># @param root, a tree node</span>
</span><span class="line">    <span class="c"># @return a list of integers</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
</span><span class="line">        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
</span><span class="line">            <span class="k">return</span> <span class="p">[]</span>
</span><span class="line">        <span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>
</span><span class="line">        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
</span><span class="line">            <span class="n">ans</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
</span><span class="line">        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
</span><span class="line">            <span class="n">ans</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ans</span>
</span></code></pre></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Single Number]]></title>
    <link href="http://blog.loudou.info/blog/2014/08/06/single-number/"/>
    <updated>2014-08-06T16:44:56+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/08/06/single-number</id>
    <content type="html"><![CDATA[<p>最近开始撸算法相关的东西. 于是在 LeetCode 上找一些题来练习</p>

<!--more-->

<ul id="markdown-toc">
  <li><a href="#section">题目</a></li>
  <li><a href="#section-1">我的解法</a></li>
  <li><a href="#section-2">大触的解法</a>    <ul>
      <li><a href="#section-3">异或</a></li>
      <li><a href="#section-4">解</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">题目</h2>

<p>第一题还是选择简单点的好了. 选择了一个 AC 率最高的题目.</p>

<p>原题:</p>

<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>

<p>Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>

<p>翻译:</p>

<p>一个整型数组, 其中所有元素都出现了<strong>两次</strong>, 只有一个例外. 找出这个例外</p>

<p>注意:
你的算法的时间复杂度必须是线性的. 能不能不使用额外的空间就实现它?</p>

<h2 id="section-1">我的解法</h2>

<p>使用 Cache 计数. 可以 AC, 但使用了额外空间.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span><span class="line">    <span class="c"># @param A, a list of integer</span>
</span><span class="line">    <span class="c"># @return an integer</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">singleNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
</span><span class="line">        <span class="n">cached</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>  <span class="n">A</span><span class="p">:</span>
</span><span class="line">            <span class="n">cached</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cached</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class="line">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cached</span><span class="p">:</span>
</span><span class="line">            <span class="k">if</span> <span class="n">cached</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span><span class="line">                <span class="k">return</span> <span class="n">i</span>
</span></code></pre></div></figure></notextile></div>

<p>这种方法算是比较通用的通用的解法吧. 重复的元素可以不限制于<strong>两次</strong></p>

<p>也许, 正因为没有利用到<strong>两次</strong>这个条件, 所以才需要使用到额外空间?</p>

<p>如果先排序的话倒是可以通过比较前后两个元素是否相等来寻找唯一元素.</p>

<p>但是目前撸过的排序算法里面就没有线性复杂度的…所以放弃了..</p>

<h2 id="section-2">大触的解法</h2>

<p>之后浏览了下讨论区. 似乎使用 nlg(n) 复杂度的也 AC 了..</p>

<p>不过看到一个相当 trick 的解法 – 使用<code>异或</code>计算<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<h3 id="section-3">异或</h3>

<p>简单说明下异或操作:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>             <span class="c"># 1 -&gt; 0x01 -&gt; 00000001</span>
</span><span class="line"><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>             <span class="c"># 2 -&gt; 0x02 -&gt; 00000010</span>
</span><span class="line"><span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span>         <span class="c"># 3 -&gt; 0x03 -&gt; 00000011</span>
</span></code></pre></div></figure></notextile></div>

<p>把整型数按位进行计算. 同为0或1则得到0, 一个0一个1则得到1
因此得到上面的 <code>1 ^ 2 = 3</code> 的计算</p>

<p>关于异或, 比较特殊的计算</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">a</span> <span class="o">^</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class="line"><span class="n">a</span> <span class="o">^</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">a</span>
</span><span class="line"><span class="n">a</span> <span class="o">^</span> <span class="n">b</span> <span class="o">==</span> <span class="n">b</span> <span class="o">^</span> <span class="n">a</span>
</span></code></pre></div></figure></notextile></div>

<p>大触的解法里就用到了上面的公式</p>

<h3 id="section-4">解</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span><span class="line">    <span class="c"># @param A, a list of integer</span>
</span><span class="line">    <span class="c"># @return an integer</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">singleNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
</span><span class="line">        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
</span><span class="line">            <span class="n">ans</span> <span class="o">^=</span> <span class="n">i</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ans</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class="line">    <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span><span class="line">    <span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
</span><span class="line">    <span class="k">print</span> <span class="n">s</span><span class="o">.</span><span class="n">singleNumber</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></code></pre></div></figure></notextile></div>

<p>原理就是上面提到的特殊计算: (2^2) ^ (3^3) ^ (5^5) ^ 4 = 4</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>给大触们跪了 Orz<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[df 与 du 结果不匹配问题]]></title>
    <link href="http://blog.loudou.info/blog/2014/08/04/df-yu-du-jie-guo-bu-pi-pei-wen-ti/"/>
    <updated>2014-08-04T22:03:28+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/08/04/df-yu-du-jie-guo-bu-pi-pei-wen-ti</id>
    <content type="html"><![CDATA[<p>du 与 df 与 文件描述符不得不说的故事</p>

<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">案发现场</a></li>
  <li><a href="#section-1">侦探们</a>    <ul>
      <li><a href="#df">df</a></li>
      <li><a href="#du">du</a></li>
      <li><a href="#lsof">lsof</a></li>
    </ul>
  </li>
  <li><a href="#section-2">真相只有一个</a></li>
  <li><a href="#section-3">现场还原</a></li>
</ul>

<h2 id="section">案发现场</h2>

<p>开发同学接到了 cacti 的预警. 一台生产机器硬盘吃紧, 使用量达到了 90% 以上</p>

<p>这里不方便给截图, 请看官们自行脑补…</p>

<h2 id="section-1">侦探们</h2>

<h3 id="df">df</h3>
<p>首先, 我们派出第一位侦探 <code>df</code>, 以确认被占用的硬盘.</p>

<p><code>df</code> 给出的调查报告如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><pre><code class=""><span class="line">ralph -&gt; df -h
</span><span class="line">Filesystem      Size  Used Avail Use% Mounted on
</span><span class="line">/dev/xvda1       20G   19G  972K 100% /
</span><span class="line">tmpfs           245M     0  245M   0% /dev/shm
</span><span class="line">/dev/xvdb1       40G  6.9G   31G  19% /data</span></code></pre></div></figure></notextile></div>

<p>根据 <code>df</code> 先生的报告, 我们确认被占用的磁盘为 /dev/xvda1, 其挂载目录为 <code>/</code></p>

<h3 id="du">du</h3>

<p>接下来, 该 <code>du</code> 先生出场了, 他会帮我们找到那该死的大文件在哪目录下面的.</p>

<p>我们先看他的第一次报告.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><pre><code class=""><span class="line">ralph -&gt; du --max-depth=1 -h /
</span><span class="line">164K    /dev
</span><span class="line">5.9M    /bin
</span><span class="line">0       /sys
</span><span class="line">4.0K    /mnt
</span><span class="line">18M     /lib64
</span><span class="line">39M     /boot
</span><span class="line">292M    /var
</span><span class="line">603M    /root
</span><span class="line">5.5G    /usr
</span><span class="line">4.0K    /selinux
</span><span class="line">6.7G    /data
</span><span class="line">9.4M    /sbin
</span><span class="line">0       /proc
</span><span class="line">6.6M    /etc
</span><span class="line">75M     /tmp
</span><span class="line">239M    /lib
</span><span class="line">4.0K    /opt
</span><span class="line">4.0K    /media
</span><span class="line">699M    /home
</span><span class="line">20K     /lost+found
</span><span class="line">4.0K    /srv
</span><span class="line">15G     /</span></code></pre></div></figure></notextile></div>

<p>嗯, 从 <code>/</code> 中减掉 <code>/data</code> 目录下的 6.7G. 还有 8.3G.</p>

<p>O_O’’’</p>

<p><code>du</code> !!!! 你玩儿我呢吧… <code>df</code> 已经明确除了 <code>/data</code>, <code>/</code> 目录下应该还有 19G 文件. 是不是不想干了!!!</p>

<h3 id="lsof">lsof</h3>

<p>这时, <code>lsof</code> 主动站出来说话了: 逗逼攻城狮, <em>说不定是有进程在向已删除的文件写数据啊!</em></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><pre><code class=""><span class="line">ralph -&gt; lsof |grep delete
</span><span class="line">grep      12574  ralph  txt       REG  202,1    106232  720903 /bin/grep (deleted)
</span><span class="line">grep      12574  ralph    1u      CHR  136,2       0t0       5 /dev/pts/2 (deleted)
</span><span class="line">grep      12574  ralph    2u      CHR  136,2       0t0       5 /dev/pts/2 (deleted)
</span><span class="line">python    28230  ralph    3w      REG  202,1 734003200  401905 /home/ralph/tmp/write.log (deleted)</span></code></pre></div></figure></notextile></div>

<p>嗯~ 原来如此…杀掉这个 <code>28239</code> 这个 Python 进程后, 磁盘占用恢复正常</p>

<h2 id="section-2">真相只有一个</h2>

<ul>
  <li>
    <p>首先, 在 Linux 系统下, 当一个程序以 <code>写模式</code> 打开一个文件后, 会在进程中保留一个<code>文件描述符</code>, 以便进程对磁盘进行写操作. <code>文件描述符</code> 在 <code>/proc</code> 文件系统下, 表现为一个<code>软链接</code>, 只占用 64 个字节的空间.</p>
  </li>
  <li>
    <p>其次, 而在 Linux 的文件系统中, 我们看到的所谓文件只是一个叫<code>硬链接</code>的东西, 而且可以有多个<code>硬链接</code>指向同一个文件(调..啊不,和 <code>ln</code> 妹纸沟通过就知道). 当指向某一文件块的所有<code>硬链接</code>被删除后, Linux 才会回收对相应磁盘空间的占用</p>
  </li>
</ul>

<p>而此次事件的原因, 正好是<code>文件描述符</code>和<code>硬链接</code>指向同一块磁盘空间造成的.</p>

<p>故事应该是这样发生的:</p>

<ol>
  <li>Python 进程打开了 <code>write.log</code> 的文件描述符, 进行写操作. 但却忘记关闭其描述符   </li>
  <li>Linux 上部署的定时清理程序开始工作, 清理掉了 <code>write.log</code> 文件最后一个硬链接</li>
  <li>因为 Python 进程的文件描述符没有关闭, Linux 内核”不敢”回收这块已经没有硬链接的磁盘空间.</li>
  <li>磁盘空间仍被占用, 但对应目录下却没有<code>文件</code>.</li>
</ol>

<h2 id="section-3">现场还原</h2>

<p>呃, 实际上, 公司的开发语言使用的是 java. 而且, 解决问题时并没有及时截图什么的. 所以, 上面那些数据就是用<code>Python</code> 还原现场时的数据了.</p>

<p>这里再附上 Python 脚本.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line">
</span><span class="line"><span class="n">fobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;write.log&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">whil</span> <span class="bp">True</span><span class="p">:</span>
</span><span class="line">    <span class="n">fobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;*&#39;</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
</span></code></pre></div></figure></notextile></div>

<p>如果不想写太多数据出来, 可以用下面这个版本</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line">
</span><span class="line"><span class="n">fobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;write.log&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">fobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;*&#39;</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class="line">    <span class="k">pass</span>
</span></code></pre></div></figure></notextile></div>

<p>死循环的目的都是为了模拟文件描述符占用</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为 octopress 添加 TOC]]></title>
    <link href="http://blog.loudou.info/blog/2014/08/01/wei-octopress-tian-jia-toc/"/>
    <updated>2014-08-01T00:52:13+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/08/01/wei-octopress-tian-jia-toc</id>
    <content type="html"><![CDATA[<p>添加一个 TOC 方便阅读</p>

<!--more-->

<ul id="markdown-toc">
  <li><a href="#section">尝试</a></li>
  <li><a href="#kramdown-">kramdown 配置</a></li>
  <li><a href="#section-1">在文章中使用</a></li>
  <li><a href="#toc-">让 TOC 飘起来</a></li>
  <li><a href="#section-2">问题什么的</a></li>
</ul>

<h2 id="section">尝试</h2>

<p>开始时尝试了使用默认引擎 <code>rdiscount</code> 的扩展 <code>generate_toc</code>, 但效果并不好.
生成的目录不能进行点击跳转</p>

<p>切换为 <code>kramdown</code> 引擎后, TOC 解析正常.</p>

<h2 id="kramdown-">kramdown 配置</h2>

<p>要切换 <code>kramdown</code>, 只需要修改 <code>_config.yml</code> 文件中的 <code>markdown</code> 属性</p>

<p>如下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>_config.yml</span></figcaption><div class="highlight"><pre><code class="yaml"><span class="line"><span class="l-Scalar-Plain">markdown</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kramdown</span>
</span><span class="line">  <span class="l-Scalar-Plain">toc_levels</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">2..3</span>
</span></code></pre></div></figure></notextile></div>

<p>其中, <code>toc_levels</code> 是用来指定那些标题会进入目录.</p>

<p>因为写作习惯, 我这里就只配置为 h2, h3 进入目录.</p>

<h2 id="section-1">在文章中使用</h2>

<p>完成配置后, 在文章中需要的地方添加以下两行</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>_config.yml</span></figcaption><div class="highlight"><pre><code class="yaml"><span class="line"><span class="err">*</span> <span class="l-Scalar-Plain">any list</span>
</span><span class="line"><span class="l-Scalar-Plain">{:toc}</span>
</span></code></pre></div></figure></notextile></div>

<p><code>kramdown</code> 引擎会帮我们把上面两行按配置解析成 toc, 也就是目录了.</p>

<blockquote>
  <p>如果没有第一行的列表标识的话, kramdown 是不会进行正确的 toc 解析的</p>
</blockquote>

<h2 id="toc-">让 TOC 飘起来</h2>

<p>为了让 TOC 更在阅读的时候更方便, 我们需要修改一下样式</p>

<p>kramdown 解析出来的 TOC 的 id 为 <code>markdown-toc</code>. 所以我们修改样式如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="css"><span class="line"><span class="nf">#markdown</span><span class="nd">:before</span> <span class="p">{</span>
</span><span class="line">    <span class="k">content</span><span class="o">:</span> <span class="s2">&quot;目录&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="k">font-weight</span><span class="o">:</span> <span class="k">bold</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nt">ul</span><span class="nf">#markdown-toc</span> <span class="p">{</span>
</span><span class="line">    <span class="k">list-style</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
</span><span class="line">    <span class="k">position</span><span class="o">:</span> <span class="k">fixed</span><span class="p">;</span>
</span><span class="line">    <span class="k">padding</span><span class="o">:</span> <span class="m">0px</span><span class="p">;</span>
</span><span class="line">    <span class="k">left</span><span class="o">:</span> <span class="m">10px</span><span class="p">;</span>
</span><span class="line">    <span class="k">bottom</span><span class="o">:</span> <span class="m">200px</span><span class="p">;</span>
</span><span class="line">    <span class="k">border</span><span class="o">-</span><span class="n">radius</span><span class="o">:</span> <span class="m">0.3em</span><span class="p">;</span>
</span><span class="line">    <span class="n">box</span><span class="o">-</span><span class="n">shadow</span><span class="o">:</span> <span class="n">rgba</span><span class="p">(</span><span class="m">0</span><span class="o">,</span><span class="m">0</span><span class="o">,</span><span class="m">0</span><span class="o">,</span><span class="m">0</span><span class="o">.</span><span class="m">15</span><span class="p">)</span> <span class="m">0</span> <span class="m">1px</span> <span class="m">4px</span><span class="p">;</span>
</span><span class="line">    <span class="n">box</span><span class="o">-</span><span class="n">sizing</span><span class="o">:</span> <span class="k">border</span><span class="o">-</span><span class="n">box</span><span class="p">;</span>
</span><span class="line">    <span class="k">border</span><span class="o">:</span> <span class="m">#fff</span> <span class="m">0.5em</span> <span class="k">solid</span><span class="p">;</span>
</span><span class="line">    <span class="k">background-color</span><span class="o">:</span> <span class="nb">white</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></div></figure></notextile></div>

<p>这样一个在文章左边悬停的 TOC 就做了好</p>

<h2 id="section-2">问题什么的<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2>

<ul>
  <li>
    <p>kramdown 与 rdiscount 在对 markdown 的部分细节处理上有所不同. 以前的文章也要做调整</p>
  </li>
  <li>
    <p>TOC 的锚, 在跳转时因为 navbar-fixed-top 的问题, 调整 h1~h6 的样式为 {margin-top:-70px;padding-top:70px}.</p>
  </li>
  <li>
    <p>小标题能太长.. 要不会盖到文章正文</p>
  </li>
</ul>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>呃, 为一个 TOC 做到这样. 我也算蛮拼的…<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[无节操地重新认识多态和IoC]]></title>
    <link href="http://blog.loudou.info/blog/2014/07/27/zhong-xin-ren-shi-duo-tai-he-ioc/"/>
    <updated>2014-07-27T23:41:34+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/07/27/zhong-xin-ren-shi-duo-tai-he-ioc</id>
    <content type="html"><![CDATA[<h2 id="section">起源</h2>

<p>源自一则微博:</p>

<p>详情戳<a href="http://weibo.com/1854716251/BfnE2jSR9">这里</a></p>

<!--more-->

<ul id="markdown-toc">
  <li><a href="#section">起源</a></li>
  <li><a href="#ioc-">IoC 简介</a></li>
  <li><a href="#section-1">无节操的例子</a></li>
</ul>

<p>刚转这篇微博的时候, 确实只意识到它用了多态特性.</p>

<p>在自己尝试写一个 Python 版的时候, 才意识到其实这里面更多的在表达 IoC 的设计思路</p>

<h2 id="ioc-">IoC 简介</h2>

<p><code>IoC</code> 的全称是 <code>Inversion of Control</code> 译过来就是控制返转.</p>

<p><a href="http://coolshell.cn/articles/9949.html" title="酷壳">酷壳</a>有一个比较好的例子, 我这里就不重复造轮子了.</p>

<h2 id="section-1">无节操的例子</h2>

<p>这里我们详细谈一下<a href="http://weibo.com/1854716251/BfnE2jSR9" title="PHP版">起源</a>里的例子是怎么回事:</p>

<p>妹子与汉子约会, 会因为汉子的种类(高富帅或diaosi)采取不同行动.</p>

<p>一般的理解思路就是<code>妹子在做选择</code>, 也就是控制权在妹子手里.</p>

<p>这样如果用代码表示的话可能就是下面这样</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">meet</span><span class="p">(</span><span class="n">hanzi</span><span class="p">):</span>
</span><span class="line">   <span class="n">hanzi</span><span class="o">.</span><span class="n">flower</span><span class="p">()</span>
</span><span class="line">   <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hanzi</span><span class="p">,</span> <span class="n">GFS</span><span class="p">):</span>
</span><span class="line">       <span class="k">print</span> <span class="s">&#39;啪啪啪啪啪啪啪啪&#39;</span>
</span><span class="line">   <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hanzi</span><span class="p">,</span> <span class="n">DS</span><span class="p">):</span>
</span><span class="line">       <span class="k">print</span> <span class="s">&#39;啪&#39;</span>
</span></code></pre></div></figure></notextile></div>

<p>而 IoC 的理解思路却是这样的:</p>

<blockquote>
  <p><em>控制权其实在 <code>hanzi</code> 这边, 妹子对汉子的表达是相同的, 但因为 <code>hanzi</code> 的不同而产生了不同结果而已</em></p>
</blockquote>

<p>用代码来表达就是这样</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Meizi</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">meet</span><span class="p">(</span><span class="n">hanzi</span><span class="p">):</span>
</span><span class="line">        <span class="n">hanzi</span><span class="o">.</span><span class="n">flower</span><span class="p">()</span>
</span><span class="line">        <span class="n">hanzi</span><span class="o">.</span><span class="n">chu</span><span class="p">()</span>
</span></code></pre></div></figure></notextile></div>

<p><code>Meizi</code> 这边的代码是不是就变得非常干净了, 那汉子在 chu 之后的结果就不在妹子这里控制了.</p>

<p>至于发生了什么, 我们来看一下 <code>Hanzi</code> 们的具体实现</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Hanzi</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="s">&#39;Abstract class Hanzi&#39;</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">flower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&#39;妹子笑了...&#39;</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">chu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Abstract Method chu not implemented yet&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">GFS</span><span class="p">(</span><span class="n">Hanzi</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">chu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&#39;啪啪啪啪啪啪啪啪&#39;</span>
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">DS</span><span class="p">(</span><span class="n">Hanzi</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">chu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&#39;啪&#39;</span>
</span></code></pre></div></figure></notextile></div>

<p><strong>看, 结果的不同是因为 <code>Hanzi</code> 自己的属性, 而不是妹子的选择.</strong></p>

<p>这就是 IoC 的本质了<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>其实是把妹的本质吧, 喂!!<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning the Bash Shell 笔记-Debug]]></title>
    <link href="http://blog.loudou.info/blog/2014/06/11/learning-the-bash-shell-bi-ji-debug/"/>
    <updated>2014-06-11T10:40:33+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/06/11/learning-the-bash-shell-bi-ji-debug</id>
    <content type="html"><![CDATA[<p>任何开发测试工作都离不开的话题 – Debug. </p>

<p>bash 脚本自然也不能免俗
<!--more--></p>

<h2 id="section">显示每一步执行的命令</h2>

<p>默认情况下, bash 脚本执行时不会像 Windows 的 bat 一样显示每一次执行的命令.
虽然说这功能在执行时比较难看, 但在 Debug
时可以帮助我们查看脚本是执行到哪一行出现的问题</p>

<p>如果想让 bash 脚本运行时显示每行命令, 则需要在脚本开始添加如下命令:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nb">set</span> -o <span class="o">[</span>noexec|verbose|xtrace<span class="o">]</span>
</span></code></pre></div></figure></notextile></div>

<p>参数说明:</p>

<ul>
  <li>
    <p><code>noexec</code>	不执行脚本, 只检查语法错误</p>
  </li>
  <li>
    <p><code>verbose</code>	显示每一行命令 (开启这个功能后 bash 就和 bat 很像了)</p>
  </li>
  <li>
    <p><code>xtrace</code>	比 verbose 更详细的显示, 具体显示信息由 <code>PS4</code> 变量配置</p>
  </li>
</ul>

<h2 id="fake-signal">几个 fake signal</h2>

<h3 id="exit">EXIT</h3>

<p>在脚本退出时会触发该信号</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>exit.sh</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="c">#!/bin/sh</span>
</span><span class="line">
</span><span class="line"><span class="nb">trap</span> <span class="s1">&#39;echo exiting the script&#39;</span> EXIT
</span><span class="line">
</span><span class="line"><span class="nb">echo</span> <span class="s1">&#39;starting the script&#39;</span>
</span></code></pre></div></figure></notextile></div>

<p>执行结果:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$.</span>/exit.sh
</span><span class="line">starting the script
</span><span class="line">exiting the script
</span></code></pre></div></figure></notextile></div>

<h3 id="debug">DEBUG</h3>

<p>每一行命令执行前都会触发这个信号, 开启 <code>set -o functrace</code> 后函数内部也会触发</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>debug.sh</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="c">#!/bin/sh</span>
</span><span class="line">
</span><span class="line"><span class="nb">trap</span> <span class="s1">&#39;echo execute $LINENO&#39;</span> DEBUG
</span><span class="line">
</span><span class="line"><span class="k">for</span> <span class="o">((</span><span class="nv">_i</span><span class="o">=</span>0;_i&lt;2;_i++<span class="o">))</span>
</span><span class="line"><span class="k">do</span>
</span><span class="line"><span class="nb">echo</span> <span class="nv">$_i</span>
</span><span class="line"><span class="k">done</span>
</span></code></pre></div></figure></notextile></div>

<p>执行结果:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$.</span>/debug.sh
</span><span class="line">execute 5
</span><span class="line">execute 5
</span><span class="line">execute 7
</span><span class="line">0
</span><span class="line">execute 5
</span><span class="line">execute 5
</span><span class="line">execute 7
</span><span class="line">1
</span><span class="line">execute 5
</span><span class="line">execute 5
</span></code></pre></div></figure></notextile></div>

<h3 id="err">ERR</h3>
<p>当有命令执行后的返回值不是 0 时触发该信号</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>err.sh</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="c">#!/bin/sh</span>
</span><span class="line">
</span><span class="line"><span class="nb">trap</span> <span class="s1">&#39;echo Error with status $?&#39;</span> ERR
</span><span class="line">
</span><span class="line"><span class="k">function </span>bad
</span><span class="line"><span class="o">{</span>
</span><span class="line">	<span class="k">return </span>111
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line">bad
</span></code></pre></div></figure></notextile></div>

<p>执行结果</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$.</span>/err.sh
</span><span class="line">Error with status 111
</span></code></pre></div></figure></notextile></div>

<h3 id="return">RETURN</h3>
<p>当用 <code>source</code> 执行脚本返回后触发该信号</p>

<p>若执行 <code>set -o functrace</code>, 则函数返回后也能触发该信号</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>x.sh</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nb">echo</span> <span class="s2">&quot;Hello World&quot;</span>
</span></code></pre></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>return.sh</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="c">#!/bin/sh</span>
</span><span class="line"><span class="nb">trap</span> <span class="s1">&#39;echo debug occured&#39;</span> DEBUG
</span><span class="line"><span class="nb">trap</span> <span class="s1">&#39;echo return occured&#39;</span> RETURN
</span><span class="line">
</span><span class="line"><span class="nb">source</span> ./x.sh
</span></code></pre></div></figure></notextile></div>

<p>执行结果</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">debug occured
</span><span class="line">Hello World
</span><span class="line"><span class="k">return </span>occured
</span></code></pre></div></figure></notextile></div>

<h2 id="debugger">一个简易的 Debugger</h2>

<p>一个 Debugger 需要的功能点:</p>

<ul>
  <li>
    <p>断点</p>
  </li>
  <li>
    <p>逐步执行</p>
  </li>
  <li>
    <p>变量监视</p>
  </li>
  <li>
    <p>显示当前执行位置和断点位置</p>
  </li>
  <li>
    <p>不需要改动源码即可进行 Debug</p>
  </li>
</ul>

<h2 id="section-1">实现原理:</h2>
<p>利用 <code>DEBUG</code> 信号中断执行. 进而进入 debug 命令行</p>

<h2 id="section-2">核心数组:</h2>
<ul>
  <li>
    <p><code>_lines</code> 用来存储所有 Debug 脚本的代码</p>
  </li>
  <li>
    <p><code>_linebp</code> 用来存储断点行号</p>
  </li>
</ul>

<p>文件结构:</p>

<blockquote>
  <p>bashdb  # 主脚本, 即驱动器</p>
</blockquote>

<blockquote>
  <p>bashdb.pre # 添加到原脚本头的部分</p>
</blockquote>

<blockquote>
  <p>bashdb.fns # 定义的函数们</p>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>bashdb</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="c">#!/bin/sh</span>
</span><span class="line">
</span><span class="line"><span class="nv">_dbname</span><span class="o">=</span><span class="k">${</span><span class="nv">0</span><span class="p">##*/</span><span class="k">}</span>
</span><span class="line"><span class="nb">echo</span> <span class="s1">&#39;Bash Debugger Version 1.0&#39;</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="o">((</span> <span class="nv">$# </span>&lt; 1 <span class="o">))</span>
</span><span class="line"><span class="k">then</span>
</span><span class="line"><span class="k">	</span><span class="nb">echo</span> <span class="s2">&quot;$_dbname Usage: $_dbname filename.&quot;</span> &gt;&amp;2
</span><span class="line">	<span class="nb">exit </span>1
</span><span class="line"><span class="k">fi</span>
</span><span class="line">
</span><span class="line"><span class="nv">_guineapig</span><span class="o">=</span><span class="nv">$1</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="o">[</span> -r <span class="nv">$_guineapig</span> <span class="o">]</span>
</span><span class="line"><span class="k">then</span>
</span><span class="line"><span class="k">	</span><span class="nb">echo</span> <span class="s2">&quot;$_dbname: file &#39;$1&#39; is not readable.&quot;</span> &gt;&amp;2
</span><span class="line">	<span class="nb">exit </span>1
</span><span class="line"><span class="k">fi</span>
</span><span class="line">
</span><span class="line"><span class="nb">shift</span>
</span><span class="line">
</span><span class="line"><span class="nv">_tmpdir</span><span class="o">=</span>/tmp
</span><span class="line"><span class="nv">_libdir</span><span class="o">=</span>.
</span><span class="line"><span class="nv">_debugfile</span><span class="o">=</span><span class="nv">$_tmpdir</span>/bashdb.<span class="nv">$$</span> <span class="c"># tmp file for script debugged</span>
</span><span class="line">
</span><span class="line">cat <span class="nv">$_libdir</span>/bashdb.pre <span class="nv">$_guineapig</span> &gt; <span class="nv">$_debugfile</span>
</span><span class="line"><span class="nb">exec </span>bash <span class="nv">$_debugfile</span> <span class="nv">$_guineapig</span> <span class="nv">$_tmpdir</span> <span class="nv">$_libdir</span> <span class="s2">&quot;$@&quot;</span>
</span></code></pre></div></figure></notextile></div>

<blockquote>
  <p>关于 <code>exec</code> 命令
&gt; 执行其参数, 用其并替代当前进程. 脚本中在 <code>exec</code> 后的命令都不会执行
&gt; 在 cli 中执行 exec 后… 当前 shell 会直接退出</p>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>bashdb.pre</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="c">#!/bin/sh</span>
</span><span class="line">
</span><span class="line"><span class="nv">_debugfile</span><span class="o">=</span><span class="nv">$0</span>
</span><span class="line"><span class="nv">_guineapig</span><span class="o">=</span><span class="nv">$1</span>
</span><span class="line">
</span><span class="line"><span class="nv">_tmpdir</span><span class="o">=</span><span class="nv">$2</span>
</span><span class="line"><span class="nv">_libdir</span><span class="o">=</span><span class="nv">$3</span>
</span><span class="line">
</span><span class="line"><span class="nb">shift </span>3
</span><span class="line">
</span><span class="line"><span class="c"># 将所有函数加载进来</span>
</span><span class="line"><span class="nb">source</span> <span class="nv">$_libdir</span>/bashdb.fns
</span><span class="line">
</span><span class="line"><span class="nv">_linebp</span><span class="o">=</span>
</span><span class="line"><span class="nb">let </span><span class="nv">_trace</span><span class="o">=</span>0
</span><span class="line"><span class="nb">let </span><span class="nv">_i</span><span class="o">=</span>0
</span><span class="line">
</span><span class="line"><span class="o">{</span>
</span><span class="line">	<span class="k">while </span><span class="nb">read</span>
</span><span class="line"><span class="nb">	</span><span class="k">do</span>
</span><span class="line"><span class="k">		</span>_line<span class="o">[</span><span class="nv">$_i</span><span class="o">]=</span><span class="nv">$REPLY</span>
</span><span class="line">		<span class="nb">let </span><span class="nv">_i</span><span class="o">=</span><span class="nv">$_i</span>+1
</span><span class="line">	<span class="k">done</span>
</span><span class="line"><span class="o">}</span> &lt; <span class="nv">$_guineapig</span>
</span><span class="line">
</span><span class="line"><span class="c"># 退出时清除临时文件</span>
</span><span class="line"><span class="nb">trap </span>_cleanup EXIT
</span><span class="line">
</span><span class="line"><span class="nb">let </span><span class="nv">_steps</span><span class="o">=</span>1
</span><span class="line">
</span><span class="line"><span class="c"># 减掉 bashdb.pre 的行数</span>
</span><span class="line"><span class="nb">trap</span> <span class="s1">&#39;_steptrap $(($LINENO - 32))&#39;</span> DEBUG
</span></code></pre></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>bashdb.fns</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="c">#!/bin/sh</span>
</span><span class="line">
</span><span class="line"><span class="c"># Debugger 的主要函数 _steptrap</span>
</span><span class="line"><span class="c"># 每一行代码执行前, 这个函数都会被调用</span>
</span><span class="line">
</span><span class="line"><span class="k">function </span>_steptrap
</span><span class="line"><span class="o">{</span>
</span><span class="line">	<span class="nv">_curlline</span><span class="o">=</span><span class="nv">$1</span>
</span><span class="line">	<span class="o">((</span> <span class="nv">$trace</span> <span class="o">))</span> <span class="o">&amp;&amp;</span> _msg <span class="s2">&quot;Line $_curlline: ${_lines[$_curlline]}&quot;</span>
</span><span class="line">
</span><span class="line">	<span class="k">if</span> <span class="o">((</span> <span class="nv">$_steps</span> &gt;<span class="o">=</span> 0 <span class="o">))</span>
</span><span class="line">	<span class="k">then</span>
</span><span class="line"><span class="k">		</span><span class="nb">let </span><span class="nv">_steps</span><span class="o">=</span><span class="nv">$_steps</span>-1
</span><span class="line">	<span class="k">fi</span>
</span><span class="line">
</span><span class="line">	<span class="c"># check if there is a breakpoint</span>
</span><span class="line">	<span class="k">if </span>_at_linenumbp
</span><span class="line">	<span class="k">then</span>
</span><span class="line"><span class="k">		</span>_msg <span class="s2">&quot;Reached breakpoint at $_curlline&quot;</span>
</span><span class="line">		_cmdloop
</span><span class="line">	<span class="k">fi</span>
</span><span class="line">
</span><span class="line">	<span class="c"># check if there is a break condition</span>
</span><span class="line">	<span class="k">if</span> <span class="o">[</span> -n <span class="s2">&quot;$_brcond&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">eval</span> <span class="nv">$_brcond</span>
</span><span class="line">	<span class="k">then</span>
</span><span class="line"><span class="k">		</span>_msg <span class="s2">&quot;Break condition $_brcond true at line $_curlline&quot;</span>
</span><span class="line">		_cmdloop
</span><span class="line">	
</span><span class="line">	<span class="c"># check if there are no more steps</span>
</span><span class="line">	<span class="k">if</span> <span class="o">((</span> <span class="nv">$_steps</span> <span class="o">==</span> 0 <span class="o">))</span>
</span><span class="line">	<span class="k">then</span>
</span><span class="line"><span class="k">		</span>_msg <span class="s2">&quot;Stopped at line $_curlline&quot;</span>
</span><span class="line">		_cmdloop
</span><span class="line">	<span class="k">fi</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="c"># 命令处理函数 _cmdloop</span>
</span><span class="line">
</span><span class="line"><span class="k">function </span>_cmdloop
</span><span class="line"><span class="o">{</span>
</span><span class="line">	<span class="nb">local </span>cmd args
</span><span class="line">
</span><span class="line">	<span class="k">while </span><span class="nb">read</span> -e -p <span class="s2">&quot;bash&gt; &quot;</span> cmd args
</span><span class="line">	<span class="k">do</span>
</span><span class="line"><span class="k">		case</span> <span class="nv">$cmd</span> in
</span><span class="line">			<span class="se">\?</span>|h <span class="o">)</span> <span class="c"># 显示命令菜单</span>
</span><span class="line">				_menu ;;
</span><span class="line">			bc <span class="o">)</span> <span class="c"># 设置中断条件</span>
</span><span class="line">				_setbc <span class="nv">$args</span> ;;
</span><span class="line">			bp <span class="o">)</span> <span class="c"># 设置断点</span>
</span><span class="line">				_setbp <span class="nv">$args</span> ;;
</span><span class="line">			cb <span class="o">)</span> <span class="c"># 清除一个或全部断点</span>
</span><span class="line">				_clearbp <span class="nv">$args</span> ;;
</span><span class="line">			ds <span class="o">)</span> <span class="c"># 显示脚本和断点</span>
</span><span class="line">				_displayscript ;;
</span><span class="line">			g <span class="o">)</span> <span class="c"># 运行脚本直到断点</span>
</span><span class="line">				<span class="k">return</span> ;;
</span><span class="line">			q <span class="o">)</span> <span class="c"># 退出</span>
</span><span class="line">				<span class="nb">exit</span> ;;
</span><span class="line">			s <span class="o">)</span> <span class="c"># 执行 N 行, 默认 1 行</span>
</span><span class="line">				<span class="nb">let </span><span class="nv">_steps</span><span class="o">=</span><span class="k">${</span><span class="nv">args</span><span class="k">:-</span><span class="nv">1</span><span class="k">}</span>
</span><span class="line">			x <span class="o">)</span> <span class="c"># 开关显示所在行</span>
</span><span class="line">				_xtrace ;;
</span><span class="line">			!* <span class="o">)</span> <span class="c"># 执行 shell 命令</span>
</span><span class="line">				<span class="nb">eval</span> <span class="k">${</span><span class="nv">cmd</span><span class="p">#!</span><span class="k">}</span> <span class="nv">$args</span>;;
</span><span class="line">			* <span class="o">)</span>
</span><span class="line">				_msg <span class="s2">&quot;Invalid command: &#39;$cmd&#39;&quot;</span> ;;
</span><span class="line">		<span class="k">esac</span>
</span><span class="line"><span class="k">	done</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="c"># 设置断点命令对应函数 _setbp</span>
</span><span class="line">
</span><span class="line">functrace _setbp
</span><span class="line"><span class="o">{</span>
</span><span class="line">	<span class="c"># 没有参数就显示断点信息</span>
</span><span class="line">	<span class="k">if</span> <span class="o">[</span> -z <span class="s2">&quot;$1&quot;</span> <span class="o">]</span>
</span><span class="line">	<span class="k">then</span>
</span><span class="line"><span class="k">		</span>_listbp
</span><span class="line">	<span class="k">elif</span> <span class="o">[</span> <span class="k">$(</span><span class="nb">echo</span> <span class="nv">$1</span> | grep <span class="s1">&#39;^[0-9]*&#39;</span><span class="k">)</span> <span class="o">]</span>
</span><span class="line">	<span class="k">then</span>
</span><span class="line"><span class="k">		if</span> <span class="o">[</span> -n <span class="s2">&quot;${list[$1]&quot;</span> <span class="o">]</span>
</span><span class="line">		<span class="k">then</span> <span class="c"># 将新断点与旧断点重新排序放入 _linebp</span>
</span><span class="line">			<span class="nv">_linebp</span><span class="o">=(</span><span class="k">$(</span><span class="nb">echo</span> <span class="k">$(</span> <span class="o">(</span><span class="k">for </span>i in <span class="k">${</span><span class="nv">_linebp</span><span class="p">[@]</span><span class="k">}</span> <span class="nv">$1</span>;<span class="k">do</span>
</span><span class="line"><span class="k">			</span><span class="nb">echo</span> <span class="nv">$i</span>; <span class="k">done)</span> | sort -n<span class="k">)</span> <span class="o">))</span>
</span><span class="line">		<span class="k">else</span> <span class="c"># 空行不能设置断点</span>
</span><span class="line">			_msg <span class="s2">&quot;Breakpoints can only be set on non-blank lines&quot;</span>
</span><span class="line">		<span class="k">fi</span>
</span><span class="line"><span class="k">	else</span>
</span><span class="line"><span class="k">		</span>_msg <span class="s2">&quot;Please specify a numeric line number&quot;</span>
</span><span class="line">	<span class="k">fi</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="c">## 其它函数这里省略</span>
</span></code></pre></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning the Bash Shell 笔记-杂项]]></title>
    <link href="http://blog.loudou.info/blog/2014/06/05/learning-the-bash-shell-bi-ji-za-xiang/"/>
    <updated>2014-06-05T09:49:16+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/06/05/learning-the-bash-shell-bi-ji-za-xiang</id>
    <content type="html"><![CDATA[<p>一些零散的内容
<!--more-->
## getopts
getopts 主要用来定义和解析脚本支持的命令行选项.</p>

<p>简单用法如下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">while </span><span class="nb">getopts</span> <span class="s2">&quot;:ab:c&quot;</span> opt
</span><span class="line"><span class="k">do</span>
</span><span class="line"><span class="k">	case</span> <span class="nv">$opt</span> in
</span><span class="line">		a <span class="o">)</span>
</span><span class="line">			statements <span class="k">for</span> -a
</span><span class="line">			;;
</span><span class="line">		b <span class="o">)</span>
</span><span class="line">			<span class="nv">$OPTARG</span> is the argument value of -b
</span><span class="line">			statements <span class="k">for</span> -b
</span><span class="line">			;;
</span><span class="line">		c <span class="o">)</span>
</span><span class="line">			statements <span class="k">for</span> -c
</span><span class="line">			;;
</span><span class="line">		<span class="se">\?</span> <span class="o">)</span>
</span><span class="line">			other
</span><span class="line">	<span class="k">esac</span>
</span><span class="line"><span class="k">done</span>
</span><span class="line">
</span><span class="line"><span class="nb">shift</span> <span class="k">$((</span><span class="nv">$OPTIND</span> <span class="o">-</span> <span class="m">1</span><span class="k">))</span>
</span><span class="line">
</span><span class="line">main scripts
</span></code></pre></div></figure></notextile></div>

<ul>
  <li>
    <p>getopts 第一个字符串中声明支持的选项名 (只能单字符);
如果字符后面加有冒号(:)则表示该选项有对应的选项参数,
参数值会保存到变量<code>OPTARG</code>中</p>
  </li>
  <li>
    <p>执行过 getopt 后, 会在变量<code>OPTIND</code>中保存 (选项+选项参数) 的总个数. 用 shift $(($OPTIND - 1)) 来确保后续代码不受实际选项个数影响</p>
  </li>
  <li>
    <p>在声明所支持的选项时, 如果以冒号(:)开头, 可以忽略传入不合法的选项</p>
  </li>
</ul>

<h2 id="shell--make">shell 实现极简 make</h2>
<p>没有变量支持什么, 只是解释命令和依赖</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="c">#!/bin/sh</span>
</span><span class="line">
</span><span class="line"><span class="c">#set -o verbose</span>
</span><span class="line">
</span><span class="line">makecmd<span class="o">()</span>
</span><span class="line"><span class="o">{</span>
</span><span class="line">    <span class="nb">read </span>target colon sources
</span><span class="line">    <span class="k">for </span>src in <span class="nv">$sources</span>
</span><span class="line">    <span class="k">do</span>
</span><span class="line"><span class="k">        if</span> <span class="o">[</span> <span class="nv">$src</span> -nt <span class="nv">$target</span> <span class="o">]</span>
</span><span class="line">        <span class="k">then</span>
</span><span class="line"><span class="k">            while </span><span class="nb">read </span>cmd
</span><span class="line">            <span class="k">do</span>
</span><span class="line"><span class="k">                </span><span class="nb">echo</span> <span class="s2">&quot;$cmd&quot;</span>
</span><span class="line">                <span class="nb">eval</span> <span class="k">${</span><span class="nv">cmd</span><span class="p">#\t</span><span class="k">}</span>
</span><span class="line">            <span class="k">done</span>
</span><span class="line"><span class="k">            </span><span class="nb">break</span>
</span><span class="line"><span class="nb">        </span><span class="k">fi</span>
</span><span class="line"><span class="k">    done</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line">makecmd &lt; Makefile
</span></code></pre></div></figure></notextile></div>

<ul>
  <li>
    <p>只能处理一个命令, 不支持变量什么的</p>
  </li>
  <li>
    <p>用 read 从标准输入中读取 target colon sources</p>
  </li>
  <li>
    <p>循环判断 sources 中各依赖与 target 修改日期; <code>FILE1 -nt FIlE2</code>, <code>FILE1 -ot
FILE2</code> 用来比较两个文件修改时间</p>
  </li>
  <li>
    <p>eval “string” 将 string 作为 bash 命令解析</p>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning the Bash Shell 笔记-流控制]]></title>
    <link href="http://blog.loudou.info/blog/2014/05/22/learning-the-bash-shell-bi-ji-liu-kong-zhi/"/>
    <updated>2014-05-22T21:19:21+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/05/22/learning-the-bash-shell-bi-ji-liu-kong-zhi</id>
    <content type="html"><![CDATA[<p>但凡是代码就逃不开的流控制话题
<!--more--></p>

<h2 id="section">条件</h2>

<p>bash 中的条件值以数字 0 表示真, 非0 则为假, 并不存在布尔类型</p>

<p>其中有三种条件形式可以得到条件值</p>

<h3 id="section-1">命令的退出状态</h3>
<p>一般来说, Linux 的命令若执行成功, 则退出状态为 0, 不成功则返回 1-255</p>

<blockquote>
  <p><em>diff 命令除外, diff 返回 0 表示两个文件没有差别, 1 表示有差别, 2+
表示发生错误</em></p>
</blockquote>

<h3 id="section-2">脚本或函数的返回值</h3>

<p>在脚本或函数中, 用 return 表示结束并返回</p>

<p>当然, 在 bash 中只能返回数字类型, 返回字符串的话脚本会出错</p>

<p>另外, return 写返回值的话, 默认返回 0</p>

<blockquote>
  <p>脚本或函数中若没有用 return 返回值时, 则以最后一条命令的退出状态作为返回值</p>
</blockquote>

<h3 id="test">测试 test</h3>

<p>bash 中测试有两种写法</p>

<ul>
  <li>test condition</li>
  <li>[ condition ] <em>[ ] 两个方括号和中间条件之间必须要有一个空格</em></li>
</ul>

<p>两种写法是等价的, 详细的写法可参考 <code>man test</code></p>

<h2 id="ifelifelse">if..elif..else</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if </span>condition
</span><span class="line"><span class="k">then</span>
</span><span class="line"><span class="k">	</span>statements
</span><span class="line"><span class="o">[</span><span class="k">elif </span>condition
</span><span class="line"><span class="k">then</span>
</span><span class="line"><span class="k">	</span>statements<span class="o">]</span>
</span><span class="line"><span class="o">[</span><span class="k">else</span>
</span><span class="line"><span class="k">	</span>statements<span class="o">]</span>
</span><span class="line"><span class="k">fi</span>
</span></code></pre></div></figure></notextile></div>

<h2 id="case">case</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">case </span>epxr in
</span><span class="line">	pattern1 <span class="o">)</span>
</span><span class="line">		statements
</span><span class="line">		;;
</span><span class="line">	pattern2 <span class="o">)</span>
</span><span class="line">		statements
</span><span class="line">		;;
</span><span class="line">	...
</span><span class="line"><span class="k">esac</span>
</span></code></pre></div></figure></notextile></div>
<p><em>pattern1/2</em> 支持 bash 的通配符, 也支持 | 来表示多模式匹配</p>

<p><code>;;</code> 类似于其它语言中的 break</p>

<p>因为匹配是从上到下的, 所以可以用 <code>*)</code> 来表示 default</p>

<h2 id="select">select</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">select case</span> <span class="o">[</span>in caselist<span class="o">]</span>
</span><span class="line"><span class="k">do</span>
</span><span class="line"><span class="k">	</span>statements about <span class="nv">$case</span>
</span><span class="line">	<span class="o">[</span><span class="nb">break</span><span class="o">]</span>
</span><span class="line"><span class="k">done</span>
</span></code></pre></div></figure></notextile></div>

<p>用 caselist 里的所有项生成一个简单的选择菜单</p>

<p>statements 中 $case 就是选择的项</p>

<p>完成一次 statements 后, 若没有遇到 break 则会继续下一次 select</p>

<h2 id="for">for</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">for</span> <span class="o">((</span>expr1;expr2;expr3<span class="o">))</span>
</span><span class="line">	statements
</span><span class="line">end
</span></code></pre></div></figure></notextile></div>

<p>这个比较类似 Java 里的 for</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">for </span>i <span class="o">[</span>in list<span class="o">]</span>
</span><span class="line"><span class="k">do</span>
</span><span class="line"><span class="k">	</span>statements
</span><span class="line"><span class="k">done</span>
</span></code></pre></div></figure></notextile></div>

<p>这个感觉更像 python 里的 for</p>

<p>若省略 [in list] 的话, 则默认从 $@ 中取值</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">for </span>i in <span class="o">{</span>start..end..step<span class="o">}</span>
</span><span class="line"><span class="k">do</span>
</span><span class="line"><span class="k">	</span>statements
</span><span class="line"><span class="k">done</span>
</span></code></pre></div></figure></notextile></div>
<p>bash 4.0 以上才有的语法</p>

<h2 id="while--until">while &amp; until</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">while </span>condition
</span><span class="line"><span class="k">do</span>
</span><span class="line"><span class="k">	</span>statements
</span><span class="line"><span class="k">done</span>
</span></code></pre></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">until </span>condition
</span><span class="line"><span class="k">do</span>
</span><span class="line"><span class="k">	</span>statements
</span><span class="line"><span class="k">done</span>
</span></code></pre></div></figure></notextile></div>

<p>while condition 等价于 until ! condition</p>

<p>两者没有其它区别</p>

<h2 id="section-3">附:</h2>
<p>又一个友好地显示 PATH 的方法</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>showpath.sh</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">path</span><span class="o">=</span><span class="nv">$PATH</span>
</span><span class="line">
</span><span class="line"><span class="k">while</span> <span class="o">[</span> <span class="nv">$path</span> <span class="o">]</span>;
</span><span class="line"><span class="k">do</span>
</span><span class="line"><span class="k">	</span><span class="nb">echo</span> <span class="k">${</span><span class="nv">path</span><span class="p">%%:*</span><span class="k">}</span>
</span><span class="line">	<span class="nb">echo</span> <span class="k">${</span><span class="nv">path</span><span class="p">#*:</span><span class="k">}</span>
</span><span class="line"><span class="k">done</span>
</span></code></pre></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning The Bash Shell 笔记-变量]]></title>
    <link href="http://blog.loudou.info/blog/2014/05/15/learning-the-bash-shell-du-shu-bi-ji-bian-liang/"/>
    <updated>2014-05-15T09:35:19+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/05/15/learning-the-bash-shell-du-shu-bi-ji-bian-liang</id>
    <content type="html"><![CDATA[<!--more-->

<h2 id="section">$* 和 $@</h2>
<p>这两个变量都可以得到脚本运行得到的所有参数.</p>

<p>默认情况下, 这两个变量没有区别</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>sample.sh</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="c">#!/bin/bash</span>
</span><span class="line">
</span><span class="line"><span class="nb">echo</span> <span class="nv">$*</span>
</span><span class="line">
</span><span class="line"><span class="nb">echo</span> <span class="nv">$@</span>
</span></code></pre></div></figure></notextile></div>

<p>运行上面的脚本, 传入多个参数. 得到的两行输出结果是一样的.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$.</span>/sample.sh 1 2 3
</span><span class="line">1 2 3
</span><span class="line">1 2 3
</span></code></pre></div></figure></notextile></div>

<p>但是, 当给变量 IFS(internal field sperator) 赋上值并用双引号将 <code>$*</code> 和 <code>$@</code>
括起来, 情况就不一样了.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>sample2.sh</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="c">#!/bin/bash</span>
</span><span class="line">
</span><span class="line"><span class="nv">IFS</span><span class="o">=</span>,
</span><span class="line">
</span><span class="line"><span class="nb">echo</span> <span class="s2">&quot;$*&quot;</span>
</span><span class="line">
</span><span class="line"><span class="nb">echo</span> <span class="s2">&quot;$@&quot;</span>
</span></code></pre></div></figure></notextile></div>

<p>这时候, 在 <code>$*</code> 中不再是以空格分割所有参数, 而是由 IFS 的值 (当前脚本中为逗号)来分割</p>

<p>而 <code>$@</code> 则保持原样</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$.</span>/sample2.sh 1 2 3
</span><span class="line">1,2,3
</span><span class="line">1 2 3
</span></code></pre></div></figure></notextile></div>

<p>当用双引号括起来以后, <code>"$*"</code> 等价于 <code>"$1$IFS$2$IFS$3...$IFS$N"</code></p>

<p>而 <code>"$@"</code> 等价于 <code>"$1" "$2" "$3"... "$N"</code></p>

<h2 id="string-operator">String Operator</h2>

<p>对于 shell 变量, 还有一些操作符可以让脚本变得更活</p>

<ul>
  <li>
    <p><code>${var:-word}</code>: 如果 var 变量不存在或为 null, 则返回 word. var 变量仍然不存在或为 null</p>
  </li>
  <li>
    <p><code>${var:=word}</code>: 如果 var 变量不存在或为 null, 则将 word 赋值给 var, 并返回 var 的新值(word)</p>
  </li>
  <li>
    <p><code>${var:?msg}</code>: 如果 var 变量不存在或为 null, 则停止脚本, 并输出信息 <strong>var: msg</strong></p>
  </li>
  <li>
    <p><code>${var:+word}</code>: 如果 var 变量存在并不为 null, 则返回 word. 否则, 返回 null</p>
  </li>
  <li>
    <p><code>${var:offset:length}</code> 截取变量 var 从 offset 开始长度为 length 的字符串.  offset 从 0 开始. length 为 null 截取剩余全部.</p>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>sample3.sh</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="c">#!/bin/bash</span>
</span><span class="line">
</span><span class="line"><span class="nb">echo</span> <span class="k">${</span><span class="nv">var</span><span class="k">:-</span><span class="s2">&quot;minus&quot;</span><span class="k">}</span>
</span><span class="line">
</span><span class="line"><span class="nb">echo</span> <span class="k">${</span><span class="nv">var</span><span class="k">}</span>
</span><span class="line">
</span><span class="line"><span class="nb">echo</span> <span class="k">${</span><span class="nv">var</span><span class="p">:=</span><span class="s2">&quot;equals&quot;</span><span class="k">}</span>
</span><span class="line">
</span><span class="line"><span class="nb">echo</span> <span class="k">${</span><span class="nv">var</span><span class="k">}</span>
</span><span class="line">
</span><span class="line"><span class="nb">echo</span> <span class="k">${</span><span class="nv">var</span><span class="p">:+</span><span class="s2">&quot;plus&quot;</span><span class="k">}</span>
</span><span class="line">
</span><span class="line"><span class="nb">echo</span> <span class="k">${</span><span class="nv">var</span><span class="p">:</span><span class="nv">2</span><span class="p">:</span><span class="nv">2</span><span class="k">}</span> <span class="c">#output ua</span>
</span><span class="line">
</span><span class="line"><span class="nb">echo</span> <span class="k">${</span><span class="nv">theVar</span><span class="p">:?</span><span class="s2">&quot;should not be empty&quot;</span><span class="k">}</span>
</span></code></pre></div></figure></notextile></div>

<p>输出:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>sample3.sh</span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">minus
</span><span class="line">
</span><span class="line">equals
</span><span class="line">equals
</span><span class="line">plus
</span><span class="line">ua
</span><span class="line">sample3.sh: line 15: theVar: should not be empty
</span></code></pre></div></figure></notextile></div>

<h2 id="section-1">一个练习</h2>
<p>你收集了一专辑, 并已经统计出了不同歌手的专辑数量, 现在需要找出收集数量前 10 的歌手. 文件格式如下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>file</span></figcaption><div class="highlight"><pre><code class="text"><span class="line">5 Depeche Mode
</span><span class="line">2 Split Enz
</span><span class="line">3 Simple Minds
</span><span class="line">1 Vivaldi, Antonio
</span></code></pre></div></figure></notextile></div>

<p>ok, 实现代码很简单 <code>sort -nr file | head -n 10</code></p>

<p>不过, 书中的解答不得不说更好</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="c">#!/bin/bash</span>
</span><span class="line">
</span><span class="line"><span class="nv">filename</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="p">:?</span><span class="s2">&quot;filename missing&quot;</span><span class="k">}</span>
</span><span class="line"><span class="nv">howmany</span><span class="o">=</span><span class="k">${</span><span class="nv">2</span><span class="k">:-</span><span class="nv">10</span><span class="k">}</span>
</span><span class="line">
</span><span class="line">sort -nr <span class="nv">$filename</span> | head -n <span class="nv">$howmany</span>
</span></code></pre></div></figure></notextile></div>

<p>这样脚本化之后, 增加了可读性, 而且也不限于统计前 10.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[迂回的监控数据库连接数]]></title>
    <link href="http://blog.loudou.info/blog/2014/05/09/yu-hui-de-jian-kong-shu-ju-ku-lian-jie-shu/"/>
    <updated>2014-05-09T09:45:51+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/05/09/yu-hui-de-jian-kong-shu-ju-ku-lian-jie-shu</id>
    <content type="html"><![CDATA[<p>不能通过数据库工具监控到连接数时可用的迂回监控方法
<!--more-->
## 原理
数据库连接底层使用的也是 TCP 协议.</p>

<p>所以当连接到数据库时, 在本地也有打开一个 TCP 端口. 可以通过 nestat 查看</p>

<p>并且每有一个连接, 就会产有一个端口.</p>

<p>所以, 我们只需要数一下 netstat 中打印出来连接到数据库的端口即可</p>

<h2 id="section">代码</h2>

<div><script src="https://gist.github.com/2c5f64d45de600237f1c.js"></script>
<noscript><pre><code>#!/bin/sh

function echo_db_connect_count()
{
    current_date=`date &#39;+%Y.%m.%d.%H.%M.%S&#39;`
    netstat -an |awk &#39;{gsub(&quot;::ffff:&quot;,&quot;&quot;); print $5}&#39;|grep &quot;$1&quot; |sort | uniq -c |sed &quot;s/^/$current_date/g&quot;
}

port=${1:?&quot;port should be provide as the first argument&quot;}
step=${2:=1}


while true
do
    echo_db_connect_count $port
    sleep $step
done
</code></pre></noscript></div>

<h2 id="section-1">命令分析</h2>

<p>核心就一行, 摘出来看看:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">netstat -an |awk <span class="s1">&#39;{gsub(&quot;::ffff:&quot;,&quot;&quot;); print $5}&#39;</span>|grep <span class="s2">&quot;$port&quot;</span> |sort | uniq -c
</span><span class="line">|sed <span class="s2">&quot;s/^/$current_date/g&quot;</span>
</span></code></pre></div></figure></notextile></div>

<p>各个命令在干什么: </p>

<p><code>netstat</code> 不多说, 打印出所有打开着的端口</p>

<p><code>awk</code> 在这里做一步初步处理, gsub(“::ffff:”, “”), 是为了去除 ipv6 格式的 ip 地址.</p>

<p><code>grep</code> 就是为了过滤出想监控的端口号</p>

<p><code>sort</code> 让所有打印出来的远程连接排序, 为下一步 uniq 作铺垫</p>

<p><code>uniq</code> 去重, <code>-c</code> 计算重复的项. 这样就得到连接的总数了</p>

<p><code>sed</code> 既然是监控, 在行首添加上时间.</p>

<p>执行结果的样例:</p>

<p><img src="http://blog.loudou.info/blogimgs/net_watch.png" alt="net_watch" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分析一个 Linux 命令]]></title>
    <link href="http://blog.loudou.info/blog/2014/04/14/fen-xi-yi-ge-linux-ming-ling/"/>
    <updated>2014-04-14T22:44:14+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/04/14/fen-xi-yi-ge-linux-ming-ling</id>
    <content type="html"><![CDATA[<p>通过拆解查看 CPU 信息的组合命令, 来学习每个独立命令
<!--more--></p>

<h2 id="cpu-">查看 CPU 型号及数量</h2>
<p>原命令</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
</span></code></pre></div></figure></notextile></div>

<p>cat 和 grep 就不多说了
### cut:
help 中的说明是 ** Print selected parts of lines from each FILE to standard
output ** .  输出所有选中的行</p>

<p><code>-f2</code> 是选中第二列, 换成<code>--fields=2</code>也是可以的.</p>

<p><code>-d:</code> 则表示用冒号作为列分割符, 等价于<code>--delimiter=:</code></p>

<p><strong>其它选项:</strong></p>

<p><code>-s</code> 不包含分割符的不输出</p>

<h3 id="uniq">uniq:</h3>
<p>man 中的说明 ** report or omit repeated lines ** . 实际就是去除重复行</p>

<p><code>-c</code> 表示在输出行前加上其在原文件中出现的次数</p>

<p><strong>其它选项:</strong></p>

<p><em>和输出相关:</em></p>

<p><code>-d</code> 只输出发生了重复的行. <em>04-24 更新:</em> 重复行只输出一行</p>

<p><code>-D</code> 只输出发生了重复的行. 但输出所有重复行.</p>

<p><code>-u</code> 只输出唯一行</p>

<p><em>和比较相关:</em></p>

<p><code>-fN</code> 前N列不比较. 以空格或TAB为列分割符</p>

<p><code>-sN</code> 前N个字符不比较</p>

<p><code>-wN</code> 最多比较N个字符</p>

<p><code>-i</code> 无视大小写差别. A 与 a 视为一致</p>

<p><em>其它:</em></p>

<p><code>-z</code> 以 0 作为行末</p>

]]></content>
  </entry>
  
</feed>
