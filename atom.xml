<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[挨踢夜归人]]></title>
  <link href="http://loudou.info/atom.xml" rel="self"/>
  <link href="http://loudou.info/"/>
  <updated>2015-10-07T08:44:06+08:00</updated>
  <id>http://loudou.info/</id>
  <author>
    <name><![CDATA[_漏斗]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[几个排序算法(一)]]></title>
    <link href="http://loudou.info/blog/2015/10/06/ji-ge-pai-xu-suan-fa-yi/"/>
    <updated>2015-10-06T20:51:23+08:00</updated>
    <id>http://loudou.info/blog/2015/10/06/ji-ge-pai-xu-suan-fa-yi</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">插入排序</a>    <ul>
      <li><a href="#section-1">原理</a></li>
      <li><a href="#section-2">原地化</a></li>
    </ul>
  </li>
  <li><a href="#section-3">选择排序</a>    <ul>
      <li><a href="#section-4">原理</a></li>
      <li><a href="#section-5">原地化</a></li>
    </ul>
  </li>
  <li><a href="#section-6">冒泡排序</a>    <ul>
      <li><a href="#section-7">原理</a></li>
      <li><a href="#section-8">减少循环</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">插入排序</h2>

<h3 id="section-1">原理</h3>

<ol>
  <li>列表 A 是待排序列表, 列表 B 是空列表</li>
  <li>从列表 A 读数, 并插入列表 B. 插入时, 将元素放在顺序正确的位置</li>
  <li>当元素从列表 A 完全转移到列表 B 时, 排序完成</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">insert_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
</span><span class="line">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)):</span>
</span><span class="line">            <span class="k">if</span> <span class="n">ret</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
</span><span class="line">                <span class="n">ret</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</span><span class="line">        <span class="k">else</span><span class="p">:</span>
</span><span class="line">            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="n">ret</span>
</span></code></pre></div></figure></notextile></div>

<h3 id="section-2">原地化</h3>

<p>因为列表 A 和列表 B 中元素总和是一定的.
可以利用原始列表的已访问部分作为列表 B, 进而完成原地<sup id="fnref:inplace"><a href="#fn:inplace" rel="footnote">1</a></sup>的排序.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">insert_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span>
</span><span class="line">        <span class="n">key</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class="line">        <span class="c"># 下面整个循环都是在完成插入合适的位置</span>
</span><span class="line">        <span class="c"># 因为是原地插入, 所以需要一边搜索一边交换</span>
</span><span class="line">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span><span class="line">            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
</span><span class="line">                <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span><span class="line">                <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
</span><span class="line">            <span class="k">else</span><span class="p">:</span>
</span><span class="line">                <span class="k">break</span>
</span></code></pre></div></figure></notextile></div>

<h2 id="section-3">选择排序</h2>

<h3 id="section-4">原理</h3>

<ol>
  <li>类似于插入排序, 不同的是, 不再是按顺序从列表 A 从选择元素, 而是选择最大/最小值再插入.</li>
  <li>插入到列表 B 时不再涉及位置问题, 最大值总是插入列表头, 最小值总是插入列表尾</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">select_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line">    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
</span><span class="line">    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">        <span class="n">x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
</span><span class="line">        <span class="n">lst</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class="line">        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="n">ret</span>
</span></code></pre></div></figure></notextile></div>

<h3 id="section-5">原地化</h3>

<p>把列表前半部分看作空列表, 同样可以把<code>选择排序</code>原地化</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">select_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">        <span class="n">min_idx</span> <span class="o">=</span> <span class="n">lst</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">:]))</span>
</span><span class="line">        <span class="k">if</span> <span class="n">min_idx</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span> <span class="c"># 最小值在 i 位置时位置正确, 不交换</span>
</span><span class="line">            <span class="n">lst</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">lst</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>
</span><span class="line">            <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">lst</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>
</span><span class="line">            <span class="n">lst</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">lst</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>
</span></code></pre></div></figure></notextile></div>

<h2 id="section-6">冒泡排序</h2>

<h3 id="section-7">原理</h3>

<p><code>冒泡排序</code>和前两个排序的不同在于它一开始就是原地的.</p>

<ol>
  <li>它遍历所有索引, 每次都判断当前索引的值与后一索引顺序是否正确. 不正确则进行交换.</li>
  <li>进行等同数组长度次数的遍历后, 排序完成</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class="line">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span><span class="line">            <span class="k">if</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
</span><span class="line">                <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span><span class="line">                <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span><span class="line">                <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span></code></pre></div></figure></notextile></div>

<h3 id="section-8">减少循环</h3>

<p>因为冒泡排序的特定, 经过 N 次遍历后, 数组后面的 N 项顺序是正确的.
不需要进行再遍历.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">    <span class="n">n</span> <span class="o">=</span> <span class="n">lst</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class="line">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span><span class="line">            <span class="k">if</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
</span><span class="line">                <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span><span class="line">                <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span><span class="line">                <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span></code></pre></div></figure></notextile></div>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:inplace">
      <p>英文术语是<em>in-place</em>, 没太注意正式的中译名.<a href="#fnref:inplace" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jsonpath 和 jsonpath-rw]]></title>
    <link href="http://loudou.info/blog/2015/09/16/jsonpath-he-jsonpath-rw/"/>
    <updated>2015-09-16T18:53:48+08:00</updated>
    <id>http://loudou.info/blog/2015/09/16/jsonpath-he-jsonpath-rw</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#jsonpath">jsonpath</a></li>
  <li><a href="#python-">python 的模块</a>    <ul>
      <li><a href="#section">比较</a></li>
    </ul>
  </li>
  <li><a href="#section-6">小结</a></li>
</ul>

<h2 id="jsonpath">jsonpath</h2>

<p>关于什么是 <code>jsonpath</code>: <a href="http://goessner.net/articles/JsonPath/">出门左转</a></p>

<h2 id="python-">python 的模块</h2>

<p>python 中用于 jsonpath 解析的库有以下两个.</p>

<ul>
  <li><a href="https://pypi.python.org/pypi/jsonpath-rw/1.4.0">jsonpath-rw-ext</a></li>
  <li><a href="https://pypi.python.org/pypi/jsonpath/0.54">jsonpath</a></li>
</ul>

<p>从下载量来看, <code>jsonpath-rw-ext</code> 的使用人数更多.</p>

<p>但因为历史原因<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, 我选择使用了 <code>jsonpath</code> 模块</p>

<h3 id="section">比较</h3>

<h4 id="section-1">依赖</h4>
<p><strong>jsonpath</strong> 是一个完全独立的库, 并且只有一个文件, 不依赖外部库</p>

<p><strong>jsonpath-rw-ext</strong> 依赖 <code>jsonpath-rw</code>, <code>Babel</code>, <code>pytz</code>, <code>pbr</code>, <code>ply</code>, <code>six</code>, <code>decorator</code> 多个外部库</p>

<h4 id="section-2">语法</h4>
<p><strong>jsonpath</strong></p>

<ul>
  <li>支持 http://goessner.net/articles/JsonPath/ 提到的所有语法</li>
  <li>扩展点号语法, 支持直接使用数组索引, 类示 <code>$.key.idx</code>.</li>
</ul>

<p><strong>jsonpath-rw-ext</strong></p>

<ul>
  <li>
    <p>同样支持文档中的所有语法</p>
  </li>
  <li>
    <p>没有扩展点号语法, 如果是数组要明确使用 <code>$.key[idx]</code></p>
  </li>
  <li>
    <p>扩展了类似 <code>this</code> 这样的反引号关键词</p>
  </li>
</ul>

<h4 id="section-3">安装</h4>
<p><strong>jsonapth</strong> </p>

<ul>
  <li>虽然在 <a href="http://pypi.python.org">pypi</a> 上有索引, 但是并没有提供下载包, 需要自己手动下载并放入项目</li>
</ul>

<p><strong>jsonapth-rw</strong></p>

<ul>
  <li>可以直接用 <code>pip</code> 进行安装, 包括所有依赖</li>
  <li>使用 <code>pip</code> 需要能连接到的 pypi 服务, 一般来说需要外网</li>
</ul>

<h4 id="section-4">易用</h4>
<p><strong>jsonpath</strong> 只暴露了一个接口</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="kn">import</span> <span class="nn">jsonpath</span>
</span><span class="line"><span class="n">jsonpath</span><span class="o">.</span><span class="n">jsonpath</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
</span></code></pre></div></figure></notextile></div>

<p><strong>jsonpath-rw-ext</strong> 需要使用如下代码进行解析</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="kn">from</span> <span class="nn">jsonpath_rw_ext</span> <span class="kn">import</span> <span class="n">parse</span>
</span><span class="line"><span class="n">jsonpath_expr</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="s">&#39;foo[*].baz&#39;</span><span class="p">)</span>
</span><span class="line"><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">jsonpath_expr</span><span class="o">.</span><span class="n">find</span><span class="p">({</span><span class="s">&#39;foo&#39;</span><span class="p">:</span> <span class="p">[{</span><span class="s">&#39;baz&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">&#39;baz&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}]})]</span>
</span></code></pre></div></figure></notextile></div>

<h4 id="section-5">维护</h4>

<p><strong>jsonpath</strong> 的作者已经不再维护这个项目</p>

<p><strong>jsonpath-rw-ext</strong> 的作者仍在维护, 最新一次更新代码在上个月</p>

<h2 id="section-6">小结</h2>

<p>机器能上外网, 或者能搞个本地 pypi 镜像的情况, 还是建议用 <code>jsonpath-rw-ext</code></p>

<p>不能上外网又不想为这么个模块就做个 pypi 镜像, 那就用 <code>jsonpath</code></p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>测试机不能访问外网, 当时也不懂自己搞个 pypi 本地镜象<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bash 传参的一个细节]]></title>
    <link href="http://loudou.info/blog/2015/08/10/bash-chuan-can-de-yi-ge-xi-jie/"/>
    <updated>2015-08-10T18:04:59+08:00</updated>
    <id>http://loudou.info/blog/2015/08/10/bash-chuan-can-de-yi-ge-xi-jie</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">你四不四傻</a></li>
  <li><a href="#section-1">捉虫</a></li>
  <li><a href="#section-2">小结</a></li>
</ul>

<h2 id="section">你四不四傻</h2>

<p>写了个小函数如下:</p>

<ul>
  <li>接收两个参数</li>
  <li>如果第一个参数为空字符串, 直接 echo 第二个</li>
  <li>否则, 用逗号(,)连接两个字符串</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">append_str<span class="o">()</span> <span class="o">{</span>
</span><span class="line">    <span class="k">if</span> <span class="o">[</span> -n <span class="s2">&quot;$1&quot;</span> <span class="o">]</span>;<span class="k">then</span>
</span><span class="line"><span class="k">        </span><span class="nb">echo</span> <span class="nv">$2</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line"><span class="k">        </span><span class="nb">echo</span> <span class="nv">$1</span>,<span class="nv">$2</span>
</span><span class="line">    <span class="k">fi</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></div></figure></notextile></div>

<p>然后, 在调用时却总是不能进行到前一个分支..</p>

<p>调用如下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">for </span>i in <span class="k">$(</span>some list<span class="k">)</span>;<span class="k">do</span>
</span><span class="line">    <span class="nv">$a</span><span class="o">=</span><span class="k">$(</span>append_str <span class="nv">$a</span> <span class="nv">$i</span><span class="k">)</span>
</span><span class="line"><span class="k">done</span>
</span></code></pre></div></figure></notextile></div>

<p>得到总是类似如下结果</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">a,,b,c,d
</span></code></pre></div></figure></notextile></div>

<h2 id="section-1">捉虫</h2>

<p>添加 <code>set -x</code> 查看命令具体执行</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">append_str a
</span><span class="line">append_str a, b
</span><span class="line">append_str a,,b c
</span><span class="line">append_str a,,b,c d
</span></code></pre></div></figure></notextile></div>

<p>等等</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">append_str a
</span></code></pre></div></figure></notextile></div>

<p>第一个参数应该是个空字符串啊, 被吃啦!!</p>

<p>等等, bash 中变量好像是直接展开, 而非传值的.</p>

<p>嗯, 这样就说通了. 因为第一次调用 $a 还是空, 展开后等同于没有传值给函数</p>

<p>于是, 改个调用</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">for </span>i in <span class="k">$(</span>some list<span class="k">)</span>;<span class="k">do</span>
</span><span class="line">    <span class="nv">$a</span><span class="o">=</span><span class="k">$(</span>append_str <span class="s2">&quot;$a&quot;</span> <span class="s2">&quot;$b&quot;</span><span class="k">)</span>
</span><span class="line"><span class="k">done</span>
</span></code></pre></div></figure></notextile></div>

<p>工作正常! Good Job.</p>

<h2 id="section-2">小结</h2>

<ul>
  <li>bash 里参数如果用变量并不是直接传值, 而是先要展开</li>
  <li>使用时, 给变量包一层双引号是个好习惯</li>
</ul>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用生成器进行惰性读取]]></title>
    <link href="http://loudou.info/blog/2015/07/21/shi-yong-sheng-cheng-qi-jin-xing-duo-xing-du-qu/"/>
    <updated>2015-07-21T10:47:10+08:00</updated>
    <id>http://loudou.info/blog/2015/07/21/shi-yong-sheng-cheng-qi-jin-xing-duo-xing-du-qu</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">需求</a></li>
  <li><a href="#section-1">错误的实现</a></li>
  <li><a href="#section-2">正确的实现</a></li>
  <li><a href="#tips">tips</a></li>
</ul>

<h2 id="section">需求</h2>

<p>完成一个函数, 从文件中读取数据并按行解析</p>

<h2 id="section-1">错误的实现</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
</span><span class="line">    <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line">    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
</span><span class="line">        <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
</span><span class="line">    <span class="k">return</span> <span class="n">l</span>
</span></code></pre></div></figure></notextile></div>

<p>这样实现会将文件全部读入内存后才能返回所有解析好的数据列表,
在处理大文件时会变得非常慢,非常慢,非常慢</p>

<h2 id="section-2">正确的实现</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
</span><span class="line">    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
</span><span class="line">        <span class="k">yield</span> <span class="n">parse</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span></code></pre></div></figure></notextile></div>

<p>使用生成器的方式, 可以保留 open 提供的惰性读取特性, 使得内存占用很小</p>

<h2 id="tips">tips</h2>

<p>当需要同时读取两个文件时, 不要使用 <code>for i, j in zip(a, b)</code> 去处理, 因为 zip
需要把 a, b 全部读入, 这样破坏了惰性读取的特性.</p>

<p>正确的做法:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">f1</span> <span class="o">=</span> <span class="n">items</span><span class="p">(</span><span class="n">file_name1</span><span class="p">)</span>
</span><span class="line"><span class="n">f2</span> <span class="o">=</span> <span class="n">items</span><span class="p">(</span><span class="n">file_name2</span><span class="p">)</span>
</span><span class="line"><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class="line">    <span class="k">try</span><span class="p">:</span>
</span><span class="line">        <span class="n">i</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class="line">        <span class="n">j</span> <span class="o">=</span> <span class="n">f2</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class="line">    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
</span><span class="line">        <span class="k">break</span>
</span></code></pre></div></figure></notextile></div>

<p>主动调用生成器的 next 方法可以在使用多个生成器时保留其惰性.</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Python 搞一个分布式系统玩?]]></title>
    <link href="http://loudou.info/blog/2015/06/05/yong-python-gao-yi-ge-fen-bu-shi-xi-tong-wan/"/>
    <updated>2015-06-05T17:08:19+08:00</updated>
    <id>http://loudou.info/blog/2015/06/05/yong-python-gao-yi-ge-fen-bu-shi-xi-tong-wan</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">抽离队列</a></li>
  <li><a href="#section-1">任务分配</a></li>
  <li><a href="#section-2">任务处理</a></li>
  <li><a href="#section-3">结果输出</a></li>
  <li><a href="#section-4">一些思考</a></li>
</ul>

<p>最近在撸廖雪峰老师的 Python 教程. 算是对自己做一遍查缺补漏吧.</p>

<p>看到分布式进程一节, 自己做了一些发散. 现在写下来, 算是补一补长达 4 个月的博文空白…</p>

<p>基础的代码和结构见<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431929340191970154d52b9d484b88a7b343708fcc60000">原教程</a></p>

<h2 id="section">抽离队列</h2>

<p>为了让任务的分配和执行更自由的启动和停止.
我们必须把队列独立出来.</p>

<p>另外, 因为访问队列的客户端是共用的, 也抽离出来</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>base.py</span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line"><span class="c"># -*- coding: utf-8 -*-</span>
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span>
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">_QueueManagerServer</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span>
</span><span class="line">    <span class="k">pass</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">QueueManagerServer</span><span class="p">(</span><span class="n">task_queue</span><span class="p">,</span> <span class="n">result_queue</span><span class="p">):</span>
</span><span class="line">    <span class="n">_QueueManagerServer</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s">&#39;get_task_queue&#39;</span><span class="p">,</span> <span class="nb">callable</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">task_queue</span><span class="p">)</span>
</span><span class="line">    <span class="n">_QueueManagerServer</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s">&#39;get_result_queue&#39;</span><span class="p">,</span> <span class="nb">callable</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">result_queue</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="n">_QueueManagerServer</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">_QueueManagerClient</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span>
</span><span class="line">    <span class="k">pass</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">QueueManagerClient</span><span class="p">():</span>
</span><span class="line">    <span class="n">_QueueManagerClient</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s">&#39;get_task_queue&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="n">_QueueManagerClient</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s">&#39;get_result_queue&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="n">_QueueManagerClient</span>
</span></code></pre></div></figure></notextile></div>

<p>因为具体的队列是在<strong>队列程序</strong>(<code>q.py</code>)中创建的, 所以这里 <code>base.py</code> 只提供一个函数.</p>

<p>客户端虽然不需要在使用时绑定具体队列, 但为了接口调用的一致, 仍然封装到一个函数</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>q.py</span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line"><span class="c"># -*- coding: utf-8 -*-</span>
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">base</span> <span class="kn">import</span> <span class="n">QueueManagerServer</span>
</span><span class="line"><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Queue</span>
</span><span class="line">
</span><span class="line"><span class="n">task_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
</span><span class="line"><span class="n">result_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="n">Server</span> <span class="o">=</span> <span class="n">QueueManagerServer</span><span class="p">(</span><span class="n">task_queue</span><span class="p">,</span> <span class="n">result_queue</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">manager</span> <span class="o">=</span> <span class="n">Server</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="n">b</span><span class="s">&#39;secret&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">manager</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="n">manager</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</span></code></pre></div></figure></notextile></div>

<p>这里最后一定要调用 join 来防止程序直接退出.</p>

<h2 id="section-1">任务分配</h2>

<p>这里我们让处理器”分布式”的向某个 webserver 发请求.</p>

<p>因为只是一个示例, 我们就直接向队列里输入要请求的 url.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>dispatcher.py</span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line"><span class="c"># -*- coding: utf-8 -*-</span>
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">base</span> <span class="kn">import</span> <span class="n">QueueManagerClient</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="n">client</span> <span class="o">=</span> <span class="n">QueueManagerClient</span><span class="p">()(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="n">b</span><span class="s">&#39;secret&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">client</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="n">task</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_task_queue</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="n">n</span> <span class="o">=</span> <span class="mi">1000000</span>
</span><span class="line"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class="line">    <span class="n">task</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s">&#39;http://localhost:8888/?q={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</span></code></pre></div></figure></notextile></div>

<h2 id="section-2">任务处理</h2>

<p>因为不太喜欢依赖 <code>try...except</code>, 所以在取数据前加上一队列空的检查</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>worker.py</span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line"><span class="c"># -*- coding: utf-8 -*-</span>
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">base</span> <span class="kn">import</span> <span class="n">QueueManagerClient</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">random</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">requests</span>
</span><span class="line">
</span><span class="line"><span class="n">client</span> <span class="o">=</span> <span class="n">QueueManagerClient</span><span class="p">()(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="n">b</span><span class="s">&#39;secret&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">print</span> <span class="s">&#39;connect to queue...&#39;</span>
</span><span class="line"><span class="n">client</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="n">task</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_task_queue</span><span class="p">()</span>
</span><span class="line"><span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_result_queue</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
</span><span class="line">    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</span><span class="line">    <span class="k">try</span><span class="p">:</span>
</span><span class="line">        <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</span><span class="line">    <span class="k">except</span><span class="p">:</span>
</span><span class="line">        <span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line">    <span class="k">else</span><span class="p">:</span>
</span><span class="line">        <span class="n">ok</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">finally</span><span class="p">:</span>
</span><span class="line">        <span class="n">rt</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
</span><span class="line">        <span class="k">return</span> <span class="p">{</span><span class="s">&#39;ok&#39;</span><span class="p">:</span> <span class="n">ok</span><span class="p">,</span> <span class="s">&#39;rt&#39;</span><span class="p">:</span> <span class="n">rt</span><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class="line">    <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&#39;no task yet, wait 5s...&#39;</span>
</span><span class="line">        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class="line">        <span class="k">continue</span>
</span><span class="line">    <span class="k">try</span><span class="p">:</span>
</span><span class="line">        <span class="n">i</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&#39;get {0}...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&#39;request...&#39;</span>
</span><span class="line">        <span class="n">o</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class="line">        <span class="n">result</span><span class="o">.</span><span class="n">put</span><span class="p">({</span><span class="s">&#39;i&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="s">&#39;o&#39;</span><span class="p">:</span> <span class="n">o</span><span class="p">})</span>
</span><span class="line">    <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&#39;Error: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</span></code></pre></div></figure></notextile></div>

<h2 id="section-3">结果输出</h2>

<p>这里我把结果输出也抽离出来了.</p>

<p>实际上应该根据应用来决定是放到 <code>dispatcher.py</code> 里, 还是抽离出来</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>output.py</span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line"><span class="c"># -*- coding: utf-8 -*-</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">base</span> <span class="kn">import</span> <span class="n">QueueManagerClient</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">time</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="n">client</span> <span class="o">=</span> <span class="n">QueueManagerClient</span><span class="p">()(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="n">b</span><span class="s">&#39;secret&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">client</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_result_queue</span><span class="p">()</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class="line">    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&#39;no result yet, wait 5s&#39;</span>
</span><span class="line">        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class="line">        <span class="k">continue</span>
</span><span class="line">    <span class="k">try</span><span class="p">:</span>
</span><span class="line">        <span class="k">print</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&#39;Error: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</span></code></pre></div></figure></notextile></div>

<h2 id="section-4">一些思考</h2>

<p>实际上因为 QueueManager 的协议对开发者并不透明,
这样的<strong>分布式</strong>系统只能完全由 <code>Python</code> 来构建.</p>

<p>如果某部分需要更换语言会变得比较吃力.</p>

<p>相对的, 如果将队列更换成其它透明的队列服务(如, <code>memcacheq</code>), 
再定义好队列的数据格式. 便可以很容易的实现跨语言的<strong>分布式</strong>系统</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[装饰器与多进程以及Pickle]]></title>
    <link href="http://loudou.info/blog/2015/02/15/zhuang-shi-qi-yu-duo-jin-cheng-yi-ji-pickle/"/>
    <updated>2015-02-15T21:39:08+08:00</updated>
    <id>http://loudou.info/blog/2015/02/15/zhuang-shi-qi-yu-duo-jin-cheng-yi-ji-pickle</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">缘起</a></li>
  <li><a href="#section-1">解答</a></li>
  <li><a href="#section-2">分析</a></li>
</ul>

<h2 id="section">缘起</h2>

<p>因为需要并发请求同时计时, 写上如下代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">_wrap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span><span class="line">        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</span><span class="line">        <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ret</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
</span><span class="line">    <span class="k">return</span> <span class="n">_wrap</span>
</span><span class="line">
</span><span class="line"><span class="nd">@timer</span>
</span><span class="line"><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
</span><span class="line">    <span class="k">return</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">rets</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
</span><span class="line">    <span class="n">rets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">get</span><span class="p">,</span> <span class="p">(</span><span class="n">url</span><span class="p">,)))</span>
</span><span class="line"><span class="k">for</span> <span class="n">ret</span> <span class="ow">in</span> <span class="n">rets</span><span class="p">:</span>
</span><span class="line">    <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</span></code></pre></div></figure></notextile></div>

<p>好的, 来执行脚本…</p>

<p>得到了如下错误, WTF:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">PicklingError</span><span class="p">:</span> <span class="n">Can</span><span class="s">&#39;t pickle &lt;type &#39;</span><span class="n">function</span><span class="s">&#39;&gt;: attribute lookup __builtin__.function failed</span>
</span></code></pre></div></figure></notextile></div>

<p>=,= 和 Pickle 有毛关系, 百思不得…</p>

<h2 id="section-1">解答</h2>

<p>这时候先上搜索引擎.</p>

<p>在 SO 上得到了这样一对问答: <a href="http://stackoverflow.com/questions/9336646/python-decorator-with-multiprocessing-fails">戳这里</a></p>

<p>简单总结一下:</p>

<ul>
  <li>进程间通信时, 对象(数据)的传输是需要序列化的.</li>
  <li>Python 中对象序列化最常见的方法是 Pickle</li>
  <li>不是所有的 Python 对象都可以用 Pickle 序列化</li>
  <li>函数装饰器反回的函数对象就不在可 Pickle 对象之列</li>
  <li>换成类装饰器就万事大吉</li>
</ul>

<p>好了, 先来结出类装饰器的版本:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">timer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span><span class="line">        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</span><span class="line">        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ret</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
</span><span class="line">
</span><span class="line"><span class="nd">@timer</span>
</span><span class="line"><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
</span><span class="line">    <span class="k">return</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</span></code></pre></div></figure></notextile></div>

<h2 id="section-2">分析</h2>

<p>现在, 来分析一下为什么类装饰器就可以序列化, 而函数装饰器就不可以</p>

<p>先来看, 那些对象是可以序列化的. 参考<a href="https://docs.python.org/2/library/pickle.html#what-can-be-pickled-and-unpickle">官方文档</a></p>

<p>把这个问题相关的简单翻译一下:</p>

<ul>
  <li>只含有可 Pickle 元素的<code>元组</code>/<code>列表</code>/<code>集合</code>/<code>字典</code></li>
  <li>在模块顶层定义的<code>函数</code></li>
  <li><code>__dict__</code> 属性或 <code>__getstarte__()</code> 函数的返回可以 Pickle 的<code>实例</code></li>
</ul>

<h4 id="section-3">函数装饰器</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">_wrap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span><span class="line">        <span class="c"># 省略</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ret</span>
</span><span class="line">    <span class="k">return</span> <span class="n">_wrap</span>
</span></code></pre></div></figure></notextile></div>

<p>我们知道, 装饰器实际上是表达式 <code>get = timer(get)</code> 的语法糖.</p>

<p>那么, 被装饰器包裹后的 <code>get</code> 实际上就是 <code>timer</code> 的返回值 =&gt; <code>_wrap</code> 函数.</p>

<p>而这函数定义的位置是在 <code>timer</code> 内部. 并不满足 Pickle 的条件(模块顶层定义).</p>

<p>所以会导致文章开始的那个错误.</p>

<h4 id="section-4">类装饰器</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">timer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span><span class="line">        <span class="c"># 省略</span>
</span></code></pre></div></figure></notextile></div>

<p>在这里, 被装饰器包裹后的 <code>get</code> 就变成了 <code>timer</code> 类的实例.</p>

<p>既然是实例, 再加上我们没有定义 <strong>getstate</strong> 方法, 就直接来看 <strong>dict</strong> 属性</p>

<p>明显的, 这个实例的 <strong>dict</strong> 是字典 <code>{'func': &lt;function get at 0x*****&gt;}</code></p>

<p>字典所包含的元素为原始的 <code>get</code> 函数, 这个函数是定义在模块顶层的.</p>

<p>既然如此, 那么类装饰器的结果自然也就是可 Pickle 了:</p>

<p><code>原 get 可 Pickle</code> =&gt; <code>__dict__ 可 Pickle</code> =&gt; <code>实例可 Pickle</code></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 元类 DEF]]></title>
    <link href="http://loudou.info/blog/2015/01/12/python-yuan-lei-def/"/>
    <updated>2015-01-12T20:13:16+08:00</updated>
    <id>http://loudou.info/blog/2015/01/12/python-yuan-lei-def</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">元类基础</a></li>
  <li><a href="#section-1">2.* 和 3.* 的坑</a>    <ul>
      <li><a href="#section-2">兼容写法</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">元类基础</h2>

<p>Python 中一切事物都是类型的实例. </p>

<p>数值是数字类型的实例, 字符串是字符串类型的实例, 对象是类-类型的实例</p>

<p>同样的, 类(就是那个用 <code>class</code> 关键字创造出来的东西), 也是<em>某种</em>类型的实例</p>

<p>这种类型就叫<code>元类</code>.</p>

<p>如果说类是创建对象的模板, 那么<code>元类</code>就是创建类的模板</p>

<p>下面的代码就创建了一个名为 <code>meta</code> 的元类, 当然, 这个元类什么都没定义</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">meta</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s">&#39;meta&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="p">{})</span>
</span></code></pre></div></figure></notextile></div>

<p>当然, 元类的定义还有其它方法, 还请自行 <a href="https://mygso.herokuapp.com/search?q=Python+%E5%85%83%E7%B1%BB">Google</a></p>

<h2 id="section-1">2.* 和 3.* 的坑</h2>

<p>因为元类可能复用, 而要创建的类也会有一些自己的属性.</p>

<p>所以我们一般会这么写</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Cls</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">meta</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">method_of_cls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">pass</span>
</span></code></pre></div></figure></notextile></div>

<p>但是这么写有一个问题 – <code>不兼容 3.*</code></p>

<p>在 <code>3.*</code> 中, 元类语法不是上面这个样子</p>

<p>而是:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Cls</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">meta</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">method_of_cls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">pass</span>
</span></code></pre></div></figure></notextile></div>

<p>而且, 两种写法完全不兼容(不像 print)</p>

<h3 id="section-2">兼容写法</h3>

<p>语法上不兼容就没撤了?</p>

<p>如果真要兼容 <code>2.*</code> 和 <code>3.*</code>, 只能放弃 <code>class</code> 关键字, 直接使用 type 的返回值</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">Cls</span> <span class="o">=</span> <span class="n">meta</span>
</span></code></pre></div></figure></notextile></div>

<p>有需要自定义的方法的情况, 将 type 的调用封装一下就可以了.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">meta</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
</span><span class="line">    <span class="c"># do sth with name/parents/attrs</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">Cls</span> <span class="o">=</span> <span class="n">meta</span><span class="p">(</span><span class="s">&#39;Cls1&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="p">{})</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">method_of_cls2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">    <span class="k">pass</span>
</span><span class="line"><span class="n">Clas</span> <span class="o">=</span> <span class="n">meta</span><span class="p">(</span><span class="s">&#39;Cls2&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="p">{</span><span class="s">&#39;method_of_cls2&#39;</span><span class="p">:</span> <span class="n">method_of_cls2</span><span class="p">})</span>
</span></code></pre></div></figure></notextile></div>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BYE 2014]]></title>
    <link href="http://loudou.info/blog/2014/12/31/bye-2014/"/>
    <updated>2014-12-31T15:14:19+08:00</updated>
    <id>http://loudou.info/blog/2014/12/31/bye-2014</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">2014再见</a>    <ul>
      <li><a href="#section-1">搬砖</a></li>
      <li><a href="#section-6">口琴</a></li>
      <li><a href="#mooc">MOOC</a></li>
      <li><a href="#section-7">败物</a></li>
      <li><a href="#section-8">逗[哔]生活</a></li>
    </ul>
  </li>
  <li><a href="#section-9">2015你好</a></li>
</ul>

<h2 id="section">2014再见</h2>

<h3 id="section-1">搬砖</h3>

<h4 id="linux-">Linux 才是真爱</h4>

<p>没啥好说的</p>

<p>Linux 才是真爱. 终端才是真爱</p>

<h4 id="section-2">工具转换</h4>

<p>大概分三步</p>

<ul>
  <li>商业工具 LR: 方便好用, 报表美得很</li>
  <li>开源工具 Jmeter + shell: 经济实惠, 集成美得很</li>
  <li>懂原理了, 自己写工具: 妈蛋, 要多少坑有多少坑</li>
</ul>

<h4 id="section-3">玩了不少语言</h4>

<p>基本都是浅尝辄止, 最后还是用 Python</p>

<ul>
  <li>nodejs, 重新看 OO</li>
  <li>ruby, 嗯~ 语法上和 Python 相近, 但更灵活</li>
  <li>Java, 静态语言必须死</li>
  <li>Io, 卧槽, 这尼玛也可以</li>
</ul>

<h4 id="section-4">技术活动</h4>

<p>参加了下面两个技术活动</p>

<ul>
  <li>MongoDB北京2014大会</li>
  <li>SegmentFault D-Day</li>
</ul>

<p>技术活动也不是每次都有足够的干货.</p>

<p>没事的时候去听听也无妨</p>

<h4 id="section-5">一个开源项目</h4>

<p><a href="https://github.com/Ralph-Wang/should">should</a></p>

<p>把 travis + coveralls 用上. 集成测试/版本测试真心不是问题</p>

<p>单元测试真心好用. 大刀阔斧上重构, 单元测试过就 ok.</p>

<p>=,= 没人一起玩就自己给自己报 Bug, 再自己改 Bug. 反正还有一个挂着</p>

<p>代码烂得一[哔]</p>

<p>正在进行重写式重构.</p>

<h3 id="section-6">口琴</h3>

<p>妈蛋, 这是年初目标之一. 结果到 11 月才开始搞.</p>

<p>而且到现在还是一个单音都吹不好的逗[哔]</p>

<h3 id="mooc">MOOC</h3>

<p>跟了不少课.</p>

<p>但只完成了一门.</p>

<h3 id="section-7">败物</h3>

<p>懒人不拍照</p>

<ul>
  <li>MBP – 真TM贵, 真TM好用.</li>
  <li>HHKB – 嗯, 机械盘退烧了</li>
  <li>iPod Touch – 不能打电话的肾</li>
  <li>肾6 – 好大</li>
  <li>iQunix – 帅, 有[哔]格</li>
</ul>

<h3 id="section-8">逗[哔]生活</h3>

<p>就一个关键词: 十万个冷笑话</p>

<ul>
  <li>首映时间发布会 - 全场节操满地, 福利满载, 寒舞满座</li>
  <li>舞台剧 - 高还原, 笑到不行…妈蛋, 原作+主创声优都在现场, 为毛没带大师球</li>
  <li>大电影 - 咦, 电影里居然有我</li>
</ul>

<p>反正节操是透支了, 也不打算还了…</p>

<h2 id="section-9">2015你好</h2>

<ul>
  <li>
    <p>嗯, 把 should 搞好点吧.. 没人用也要做好啊喂</p>
  </li>
  <li>
    <p>多留点时间来读书啊喂. 2014 你根本就没读几本书啊</p>
  </li>
  <li>
    <p>其实…今年有那么几个月, 我觉得已经在 2015了.</p>
  </li>
</ul>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 名称空间对性能的影响]]></title>
    <link href="http://loudou.info/blog/2014/11/13/python-ming-cheng-kong-jian-dui-xing-neng-de-ying-xiang/"/>
    <updated>2014-11-13T20:03:05+08:00</updated>
    <id>http://loudou.info/blog/2014/11/13/python-ming-cheng-kong-jian-dui-xing-neng-de-ying-xiang</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">名称空间</a></li>
  <li><a href="#section-1">变量寻址</a></li>
  <li><a href="#section-2">循环优化</a></li>
</ul>

<h2 id="section">名称空间</h2>

<p>Python 中变量的作用域有一个特别的名字叫做<code>名称空间</code></p>

<p><code>名称空间</code>呢, 有以下这些特点:</p>

<ul>
  <li>每一个模块, 函数, 类, 实例, 都拥有一个独立的名称空间.    </li>
  <li>每一个变量都会处在一个名称空间下.     </li>
  <li>名称空间可以相互包含, 或者说有上下级关系</li>
  <li>在下级名称空间中可以访问上级名称空间的变量</li>
</ul>

<p>用代码来举例子:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>namespace.py</span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">in_module</span> <span class="o">=</span> <span class="s">&#39;in module&#39;</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">method</span><span class="p">():</span>
</span><span class="line">    <span class="n">in_method</span> <span class="o">=</span> <span class="s">&#39;in method&#39;</span>
</span></code></pre></div></figure></notextile></div>

<p>在上面这段代码中, 一共有 个名称空间, 分别是:</p>

<ul>
  <li>文件, 就是 <code>namespace.py</code> 里面, 有<code>in_module</code> 变量</li>
  <li>函数, 就是 <code>method</code> 里面, 有<code>in_method</code> 变量</li>
</ul>

<p>以上名称空间, 从上向下都是包含关系.</p>

<h2 id="section-1">变量寻址</h2>

<p>一般来讲, 在一个名称空间中, 只能访问到属于这个名称空间的变量</p>

<p>所以对于上面的代码来讲:</p>

<table>
  <thead>
    <tr>
      <th>名称空间</th>
      <th>可见变量</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>namespace.py</td>
      <td><code>in_module</code></td>
    </tr>
    <tr>
      <td>method</td>
      <td><code>in_method</code></td>
    </tr>
  </tbody>
</table>

<p>同时, 下级名称空间是可以访问到上级名称空间中的变量的.  <br />
于是上表就变成了</p>

<table>
  <thead>
    <tr>
      <th>名称空间</th>
      <th>可见变量</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>namespace.py</td>
      <td><code>in_module</code></td>
    </tr>
    <tr>
      <td>method</td>
      <td><code>in_method</code>, <code>in_module</code></td>
    </tr>
  </tbody>
</table>

<p>所以现在可以在 <code>method</code> 中访问所有 <code>in_*</code> 变量  <br />
就像下面这样</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">method</span><span class="p">():</span>
</span><span class="line">    <span class="n">in_method</span> <span class="o">=</span> <span class="s">&#39;in method&#39;</span>
</span><span class="line">    <span class="k">print</span> <span class="n">in_method</span>
</span><span class="line">    <span class="k">print</span> <span class="n">in_module</span>
</span></code></pre></div></figure></notextile></div>

<p>所谓<code>变量寻址</code>, 指的就是</p>

<blockquote>
  <p>Python 在当前名称空间下找不到变量定义时,
会继续搜索上一层名称空间, 直到顶层.</p>
</blockquote>

<p>这件事了.</p>

<p>概念说了一大堆, 和性能优化好像都没啥关系. 下面就进入正题</p>

<h2 id="section-2">循环优化</h2>

<p>在日常代码编写中, 我们有时会写类似这样的代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="kn">import</span> <span class="nn">math</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span>
</span><span class="line">        <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></code></pre></div></figure></notextile></div>

<p>上面代码中, <code>foo</code> 里并没有定义 <code>math</code>.
它是通过<code>变量寻址</code>在上一层找到了引入进来的<code>math</code>进行操作</p>

<p>并且, 在循环内部, 每访问一次 <code>math</code> 就会发生一次<code>变量寻址</code>.
这对性能有一定的损耗.</p>

<p>我们可以创建一个<code>foo</code>内部的变量直接指向我们要用的<code>math.sin</code>
然后再进入循环, 这样可以节省不少时间</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">woo</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">    <span class="n">sin</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span>
</span><span class="line">        <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></code></pre></div></figure></notextile></div>

<p>当然, 类似这样重复调用外部方法的函数, 我们可以直接用 <code>map</code> 来代替</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">moo</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span>
</span></code></pre></div></figure></notextile></div>

<p>下面是用 <code>timeit</code> 模块跑的基准测试结果:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">foo</span><span class="p">:</span> <span class="mf">20.8992490768</span>
</span><span class="line"><span class="n">woo</span><span class="p">:</span> <span class="mf">15.5716171265</span>
</span><span class="line"><span class="n">moo</span><span class="p">:</span> <span class="mf">12.033983945</span>
</span></code></pre></div></figure></notextile></div>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BASH 特别的 Patch 技巧]]></title>
    <link href="http://loudou.info/blog/2014/10/18/bash-te-bie-de-patch-ji-qiao/"/>
    <updated>2014-10-18T21:43:24+08:00</updated>
    <id>http://loudou.info/blog/2014/10/18/bash-te-bie-de-patch-ji-qiao</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">问题</a></li>
  <li><a href="#section-1">解决方案</a></li>
  <li><a href="#section-2">相关工具</a></li>
</ul>

<h2 id="section">问题</h2>

<p>9 月底爆出的 bash 漏洞, Mac 自然也受到影响.</p>

<p>但当时并没有找到苹果官方的解决方案,  <br />
而 bash 官方释出的补丁方式完全看不懂怎么用…  <br />
再加上就快升级 10.10 了.</p>

<p>想着也许会在升级时把补丁打上呢.  <br />
(呃, 其实是懒得研究官方补丁怎么用)  <br />
也就放着没管了</p>

<p>但昨天升级完后, 却发现并没有打上补丁.</p>

<p>只好硬着头皮上了.</p>

<h2 id="section-1">解决方案<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2>

<p>因为官方的补丁都是打在源码上的,  <br />
所以我们需要去 <a href="http://ftp.gnu.org/gnu/bash/">http://ftp.gnu.org/gnu/bash/</a> 下载 bash 的源码</p>

<p>没什么特别的需求的话, 就直接选最新的 4.3 版本好了. 懒人点 <a href="http://ftp.gnu.org/gnu/bash/bash-4.3.tar.gz">这里</a></p>

<p>下载完成后直接解压即可</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$ </span>tar zxvf bash-4.3.tar.gz
</span></code></pre></div></figure></notextile></div>

<p>现在不着急编译安装, 因为我们还需要在源码上打补丁.</p>

<p>我们需要到 <a href="http://ftp.gnu.org/gnu/bash/bash-4.3-patches/">bash-4.3-patches</a> 目录下把 01~30 补丁全部下载下来.</p>

<p>因为不想一个一个点, 所以玩了点小花样:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$ </span>seq -f %02g 30| xargs -Ix curl -O &lt;path-of-patches&gt;/bash43-0x
</span></code></pre></div></figure></notextile></div>

<p>好了, 把下载好的这些个补丁放到 bash 的源码目录下. 用 patch “一个一个”把补丁打上吧.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$ </span><span class="k">for </span>i in <span class="sb">`</span>seq -f %02g 30<span class="sb">`</span>; <span class="k">do </span>patch -p0 &lt; bash43-0<span class="nv">$i</span>;<span class="k">done</span>
</span></code></pre></div></figure></notextile></div>

<blockquote>
  <p>这里因为变量在重定向符后面, 所以不能用 xargs 进行</p>
</blockquote>

<p>好了, 接下来就是编译安装 -&gt; 替换原有 bash, 就好了</p>

<h2 id="section-2">相关工具</h2>

<p>patch: <a href="http://blog.chinaunix.net/uid-9525959-id-2001542.html">这里</a>有一篇文章讲得蛮详细的, 就不重新造轮子了.</p>

<p>两个 bug 的测试代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">env <span class="nv">x</span><span class="o">=</span><span class="s1">&#39;() { :;}; echo Your bash is Fucked&#39;</span>  bash -c <span class="s2">&quot;echo just test&quot;</span>
</span></code></pre></div></figure></notextile></div>

<p>没漏洞的 bash 是不会被 Fuck 的</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">env <span class="nv">X</span><span class="o">=</span><span class="err">&#39;</span><span class="o">()</span> <span class="o">{</span> <span class="o">(</span>a<span class="o">)=</span>&gt;<span class="se">\&#39;</span> bash -c <span class="s2">&quot;echo date&quot;</span>; cat <span class="nb">echo</span><span class="o">}</span>
</span></code></pre></div></figure></notextile></div>

<p>没漏洞的 bash 看到的是 date 字样.</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>因为是用官方源码打补丁, 所以 *NIX 系统通用<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[count += 1 不是原子级的]]></title>
    <link href="http://loudou.info/blog/2014/10/10/count-plus-equals-1-bu-shi-yuan-zi-ji-de/"/>
    <updated>2014-10-10T12:04:09+08:00</updated>
    <id>http://loudou.info/blog/2014/10/10/count-plus-equals-1-bu-shi-yuan-zi-ji-de</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">怀疑</a></li>
  <li><a href="#section-1">测试</a></li>
  <li><a href="#section-2">分析</a></li>
  <li><a href="#section-3">扩展</a></li>
</ul>

<h2 id="section">怀疑</h2>

<p>一直以为 Python 中类似 <code>count += 1</code> 的操作是原子级的…</p>

<p>于是在看到如下代码时, 产生了怀疑</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">done_num</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line"><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
</span><span class="line"><span class="c"># 省略...</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Trans</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">global</span> <span class="n">count</span>
</span><span class="line">        <span class="c"># ...</span>
</span><span class="line">        <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
</span><span class="line">        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class="line">        <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</span><span class="line">        <span class="c"># ...</span>
</span></code></pre></div></figure></notextile></div>

<p>看到这部分代码时, 第一反应是为毛这种统计要用全局变量做啊…  <br />
且不说这种用全局变量的行为; 为毛做个计数 + 1 也要锁一下啊. 难道计数不是原子级的吗!!!</p>

<h2 id="section-1">测试</h2>

<p>本着, <code>如果不出代码出过问题, 不会在这么逗[哔][^1]的地方加锁</code> 的想法. 用以下代码进行了测试.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">GlobalCount</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="nb">super</span><span class="p">(</span><span class="n">GlobalCount</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">global</span> <span class="n">count</span>
</span><span class="line">        <span class="k">for</span> <span class="n">dummy_i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
</span><span class="line">            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line"><span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line"><span class="n">threads_num</span> <span class="o">=</span> <span class="mi">100000</span>
</span><span class="line">
</span><span class="line"><span class="k">for</span> <span class="n">dummy_i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">threads_num</span><span class="p">):</span>
</span><span class="line">    <span class="n">threads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">GlobalCount</span><span class="p">())</span>
</span><span class="line">
</span><span class="line"><span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
</span><span class="line">    <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
</span><span class="line">    <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="k">print</span> <span class="n">count</span>
</span></code></pre></div></figure></notextile></div>

<p>如果 count += 1 是线程安全的话, 上面这段脚本执行完成后输出应该是 <code>1000000</code>. 不会多, 也不会少</p>

<p>执行以上脚本三次的结果:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">999990
</span><span class="line">999982
</span><span class="line">999940
</span></code></pre></div></figure></notextile></div>

<p>哇嚓嘞, 还真是线程不安全的…</p>

<h2 id="section-2">分析</h2>

<p>好吧, 即然线程不安全了, 那为什么呢? 为什么做个加法会线程不安全呢?</p>

<p>来看下 <code>count += 1</code> 的编译码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line">3 LOAD_CONST               1 <span class="o">(</span>1<span class="o">)</span>
</span><span class="line">6 INPLACE_ADD
</span><span class="line">7 STORE_GLOBAL             0 <span class="o">(</span>count<span class="o">)</span>
</span></code></pre></div></figure></notextile></div>

<p>假设如下场景:  <br />
1. 如果有那个一个线程完成 <code>3 LOAD_CONST</code> 后, 因为时间片消耗完了停了一小会儿. 我们假设这时 count 为 999  <br />
2. 这时候, 其它线程正常进行, 并且 count 已经增加到 1003 或者更大.  <br />
3. <code>1.</code>中的线程又得到的时间片, 完成后续步骤. 这时 count 被改回到 1000.  <br />
4. 其它线程的计数被抹掉了…</p>

<h2 id="section-3">扩展</h2>

<p>类似的在其它语言中 <code>count++</code> 等操作也有不是线程安全的</p>

<p>相关阅读: <a href="https://www.google.com/?gws_rd=ssl#q=i%2B%2B+%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">来自Google</a></p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BASH 中 的正则表达式(误)]]></title>
    <link href="http://loudou.info/blog/2014/10/09/bash-zhong-de-zheng-ze-biao-da-shi-wu/"/>
    <updated>2014-10-09T14:45:30+08:00</updated>
    <id>http://loudou.info/blog/2014/10/09/bash-zhong-de-zheng-ze-biao-da-shi-wu</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">源</a></li>
  <li><a href="#section-1">思考</a></li>
  <li><a href="#section-2">总结</a></li>
</ul>

<h2 id="section">源</h2>

<p>今天在写一个 bash 脚本时, 有一部分需要判断 ip 的格式.  <br />
这样的功能自然就想到了高大上的<code>正则表达式</code>同学.</p>

<p>但记得 bash 并不直接支持正则表达式. 于是用 <code>sed</code> 实现了这个功能.</p>

<p>不过, 因为好奇大牛们是怎么处理类似问题的, 仍然去搜索了一下.</p>

<p>发现原来 bash 也支持正则表达式(误).   <br />
大概说法是这样的. 在 <code>[[ ]]</code> 中写正则就可以了. 下面是一个例子</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">1</span> <span class="o">=</span>~ <span class="o">[</span>0-9<span class="o">]</span> <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span></code></pre></div></figure></notextile></div>

<p>于是用这种方式, 完成了最初那个 ip 格式判断的需求…</p>

<p>好吧, 我承认是直接抄这里的: <a href="http://openwares.net/linux/bash_regex_ip_port.html">BASH脚本中使用正则表达式检查IP地址和端口号</a></p>

<blockquote>
  <p>PS. 测试过 255.255.255.256 这样的 ip 是不通过的 : )</p>
</blockquote>

<h2 id="section-1">思考</h2>

<p>一般来说, 需求完成了. 我们就可以收工了.  <br />
但本着逗[哔]的探究精神, 对 <code>[[ ]]</code> 做了如下测试</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">1</span> <span class="o">=</span> <span class="o">[</span>0-9<span class="o">]</span> <span class="o">]]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span></code></pre></div></figure></notextile></div>

<p>结果输出: 0.</p>

<p>哇嚓, 所以 <code>=</code> 就可以了吗? 那 <code>=~</code> 是用来干嘛的???</p>

<p>正则的话, 除了 match 还有 search 方式.  <br />
Ok, 测试下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">abc123ddd</span> <span class="o">=</span> <span class="o">[</span>0-9<span class="o">]</span> <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">abc123ddd</span> <span class="o">=</span>~ <span class="o">[</span>0-9<span class="o">]</span> <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span></code></pre></div></figure></notextile></div>

<p>第一行无输出, 第二行输出: 0.</p>

<p>明了: <code>=</code> 是完全匹配, 即 match; <code>=~</code> 部分匹配, 即 search</p>

<p>好了, 再来试一下其它元字符</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">12</span> <span class="o">=</span> <span class="o">[</span>0-9<span class="o">]</span>. <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span></code></pre></div></figure></notextile></div>

<p>没结果输出</p>

<p>哇嚓, 这又是怎么回事…</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">12</span> <span class="o">=</span> <span class="o">[</span>0-9<span class="o">]</span>* <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span></code></pre></div></figure></notextile></div>

<p>输出: 0.</p>

<p>难道…</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">12</span> <span class="o">=</span> ?? <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span><span class="line"><span class="k">if</span> <span class="o">[[</span> <span class="nv">12</span> <span class="o">=</span> * <span class="o">]]</span>;<span class="k">then </span><span class="nb">echo </span>0;fi
</span></code></pre></div></figure></notextile></div>

<p>以上两行均有输出.</p>

<p>原来如此, <code>[[ ]]</code> 并不支持正则表达式.
它所支持的是 <code>glob</code> 表达式, 也就是我们常说的 <code>通配符</code></p>

<h2 id="section-2">总结</h2>

<p>探索结束. 总结一下</p>

<ol>
  <li><code>[[ expression ]]</code> 并不支持正则表达式, 其支持的是 <code>glob</code> 表达式</li>
  <li><code>[[ ]]</code> 中可以用 <code>=</code> 表达匹配, 要示左侧字符串和右侧 <code>glob</code> 完全匹配</li>
  <li>也可以使用 <code>=~</code> 进行搜索, 只要左侧字符串有部分与右侧匹配即可</li>
</ol>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python 中的三元运算符]]></title>
    <link href="http://loudou.info/blog/2014/09/05/python-zhong-de-san-yuan-yun-suan-fu/"/>
    <updated>2014-09-05T11:08:30+08:00</updated>
    <id>http://loudou.info/blog/2014/09/05/python-zhong-de-san-yuan-yun-suan-fu</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">方法介绍</a>    <ul>
      <li><a href="#if-1">IF 块</a></li>
      <li><a href="#section-1">逻辑运算</a></li>
      <li><a href="#if">内联 IF</a></li>
    </ul>
  </li>
  <li><a href="#section-3">基准测试</a></li>
</ul>

<h2 id="section">方法介绍</h2>

<p>Python 原生是不支持三元运算符: <code>(expresion):val1?val2</code>  <br />
但 Python 提供了一些语法糖在模拟三元运算符的操作</p>

<p>就以下面这样一个用例来看看 Python 中可以怎么处理三元运算</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="c"><span class="line"><span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="mi">1</span><span class="o">:</span><span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">?-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span>
</span></code></pre></div></figure></notextile></div>

<p>运算含义: val 值为正则返回 1, 为负则返回 -1, 为 0 则返回 0</p>

<h3 id="if-1">IF 块<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h3>

<p>这个是最笨拙的方法. 用 <code>if...else...</code> 块实现</p>

<p>写出来后代码如下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">if_block</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
</span><span class="line">    <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">elif</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span><span class="line">    <span class="k">else</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">0</span>
</span></code></pre></div></figure></notextile></div>

<p>因为是直接用 <code>if...else...</code> 描述出三元描述符的运算过程.  <br />
所以这种实现方法是最容易理解的.</p>

<h3 id="section-1">逻辑运算</h3>

<p><code>IF 块</code> 的方法虽然很容易理解, 但是相对的代码行数略微多了点.</p>

<p>那能不能一行就搞定呢.  <br />
当然是可以的.</p>

<p>用<code>逻辑运算</code>来处理它</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">and_or</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
</span><span class="line">    <span class="k">return</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="mi">0</span>
</span></code></pre></div></figure></notextile></div>

<p>这种方法阅读起来并不是那么的直观, 但是三种方法中最接近原始表达.  <br />
其中<code>逻辑符号</code>和<code>运算符</code>对应关系如下表</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">逻辑符号</th>
      <th style="text-align: center">运算符号</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code>and</code></td>
      <td style="text-align: center"><code>?</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code>or</code></td>
      <td style="text-align: center"><code>:</code></td>
    </tr>
  </tbody>
</table>

<h4 id="section-2">不过…</h4>

<p>这种方法有一个缺点, <code>and</code> 后的值对应的布尔值必须为真.
像下面这个条件, 返回值总会是 -1</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">or</span> <span class="o">-</span><span class="mi">1</span>
</span></code></pre></div></figure></notextile></div>

<p>嘛, 毕竟它只是<code>逻辑运算</code></p>

<h3 id="if">内联 IF</h3>

<p>虽然用<code>逻辑运算</code>去 hack 是最接近三元运算最原始的表达的. 但毕竟有一个缺陷.</p>

<p>于是, 就是最后一种内联IF的写法. 很类似列表表达式</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">if_inline</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
</span></code></pre></div></figure></notextile></div>

<p>就可读性来说, 这种写法是比较差的, 但没有逻辑运算那样的缺陷.
同时, 也不像 block 版那样写三遍 return</p>

<h2 id="section-3">基准测试</h2>

<p>既然有三种不同的写法, 那三种写法的执行效率是否一样呢.</p>

<p>于是写了如下测试脚本:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ternary.py</span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">random</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">if_block</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
</span><span class="line">    <span class="s">&#39;use if block for ternary operation&#39;</span>
</span><span class="line">    <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">elif</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span><span class="line">    <span class="k">else</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">0</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">if_inline</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
</span><span class="line">    <span class="s">&#39;use if inline for ternary operation&#39;</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">and_or</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
</span><span class="line">    <span class="s">&#39;use and/or for ternary operation&#39;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="mi">0</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
</span><span class="line">    <span class="kn">import</span> <span class="nn">timeit</span>
</span><span class="line">    <span class="kn">import</span> <span class="nn">dis</span>
</span><span class="line">    <span class="k">print</span> <span class="s">&#39;if_block:&#39;</span>
</span><span class="line">    <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">if_block</span><span class="p">)</span>
</span><span class="line">    <span class="k">print</span> <span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s">&#39;if_block(random.randrange(-10,11))&#39;</span><span class="p">,</span>
</span><span class="line">                        <span class="s">&#39;from __main__ import if_block, random&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="k">print</span> <span class="s">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span>
</span><span class="line">
</span><span class="line">    <span class="k">print</span> <span class="s">&#39;if_inline:&#39;</span>
</span><span class="line">    <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">if_inline</span><span class="p">)</span>
</span><span class="line">    <span class="k">print</span> <span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s">&#39;if_inline(random.randrange(-10,11))&#39;</span><span class="p">,</span>
</span><span class="line">                        <span class="s">&#39;from __main__ import if_inline, random&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="k">print</span> <span class="s">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span>
</span><span class="line">
</span><span class="line">    <span class="k">print</span> <span class="s">&#39;and_or:&#39;</span>
</span><span class="line">    <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">and_or</span><span class="p">)</span>
</span><span class="line">    <span class="k">print</span> <span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s">&#39;and_or(random.randrange(-10,11))&#39;</span><span class="p">,</span>
</span><span class="line">                        <span class="s">&#39;from __main__ import and_or, random&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="k">print</span> <span class="s">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="n">test</span><span class="p">()</span>
</span></code></pre></div></figure></notextile></div>

<p>脚本执行结果如下:  <br />
可以很清楚的看到, 三种写法编译后的指令数是一样的.  <br />
执行时间相差也不大, 多次执行时会有一定浮动
(果然应该把 timeit 次数设置大一点么)</p>

<blockquote>
  <p><code>if_block</code> 最后多出来 2 条指令是因为 Python 中函数最后默认返回 None. 实际调用时, 不可能会执行到这两条指令</p>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="text"><span class="line">if_block:
</span><span class="line">  8           0 LOAD_FAST                0 (val)
</span><span class="line">              3 LOAD_CONST               1 (0)
</span><span class="line">              6 COMPARE_OP               4 (&gt;)
</span><span class="line">              9 POP_JUMP_IF_FALSE       16
</span><span class="line">
</span><span class="line">  9          12 LOAD_CONST               2 (1)
</span><span class="line">             15 RETURN_VALUE
</span><span class="line">
</span><span class="line"> 10     &gt;&gt;   16 LOAD_FAST                0 (val)
</span><span class="line">             19 LOAD_CONST               1 (0)
</span><span class="line">             22 COMPARE_OP               0 (&lt;)
</span><span class="line">             25 POP_JUMP_IF_FALSE       32
</span><span class="line">
</span><span class="line"> 11          28 LOAD_CONST               3 (-1)
</span><span class="line">             31 RETURN_VALUE
</span><span class="line">
</span><span class="line"> 13     &gt;&gt;   32 LOAD_CONST               1 (0)
</span><span class="line">             35 RETURN_VALUE
</span><span class="line">             36 LOAD_CONST               4 (None)
</span><span class="line">             39 RETURN_VALUE
</span><span class="line">1.25232696533
</span><span class="line">--------------------
</span><span class="line">if_inline:
</span><span class="line"> 18           0 LOAD_FAST                0 (val)
</span><span class="line">              3 LOAD_CONST               1 (0)
</span><span class="line">              6 COMPARE_OP               4 (&gt;)
</span><span class="line">              9 POP_JUMP_IF_FALSE       16
</span><span class="line">             12 LOAD_CONST               2 (1)
</span><span class="line">             15 RETURN_VALUE
</span><span class="line">        &gt;&gt;   16 LOAD_FAST                0 (val)
</span><span class="line">             19 LOAD_CONST               1 (0)
</span><span class="line">             22 COMPARE_OP               0 (&lt;)
</span><span class="line">             25 POP_JUMP_IF_FALSE       32
</span><span class="line">             28 LOAD_CONST               3 (-1)
</span><span class="line">             31 RETURN_VALUE
</span><span class="line">        &gt;&gt;   32 LOAD_CONST               1 (0)
</span><span class="line">             35 RETURN_VALUE
</span><span class="line">1.26190900803
</span><span class="line">--------------------
</span><span class="line">and_or:
</span><span class="line"> 23           0 LOAD_FAST                0 (val)
</span><span class="line">              3 LOAD_CONST               1 (0)
</span><span class="line">              6 COMPARE_OP               4 (&gt;)
</span><span class="line">              9 POP_JUMP_IF_FALSE       18
</span><span class="line">             12 LOAD_CONST               2 (1)
</span><span class="line">             15 JUMP_IF_TRUE_OR_POP     39
</span><span class="line">        &gt;&gt;   18 LOAD_FAST                0 (val)
</span><span class="line">             21 LOAD_CONST               1 (0)
</span><span class="line">             24 COMPARE_OP               0 (&lt;)
</span><span class="line">             27 POP_JUMP_IF_FALSE       36
</span><span class="line">             30 LOAD_CONST               3 (-1)
</span><span class="line">             33 JUMP_IF_TRUE_OR_POP     39
</span><span class="line">        &gt;&gt;   36 LOAD_CONST               1 (0)
</span><span class="line">        &gt;&gt;   39 RETURN_VALUE
</span><span class="line">1.27082109451
</span><span class="line">--------------------
</span></code></pre></div></figure></notextile></div>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>这三个名称都不是官方名称…<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[blockdev 命令及相关概念]]></title>
    <link href="http://loudou.info/blog/2014/08/20/blockdev-ming-ling-ji-xiang-guan-gai-nian/"/>
    <updated>2014-08-20T23:36:02+08:00</updated>
    <id>http://loudou.info/blog/2014/08/20/blockdev-ming-ling-ji-xiang-guan-gai-nian</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section">命令本身</a></li>
  <li><a href="#report-">report 的内容</a></li>
</ul>

<h2 id="section">命令本身</h2>

<p><code>blockdev</code> 是直接调用 <code>ioctl</code> 函数的一个命令.</p>

<p>其原生帮助如下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$ </span>blockdev
</span><span class="line">
</span><span class="line">用法:
</span><span class="line">  blockdev -V
</span><span class="line">  blockdev --report <span class="o">[</span>devices<span class="o">]</span>
</span><span class="line">  blockdev <span class="o">[</span>-v|-q<span class="o">]</span> commands devices
</span><span class="line">
</span><span class="line">可用命令:
</span><span class="line">    <span class="c"># 这里暂时省略.</span>
</span></code></pre></div></figure></notextile></div>

<ul>
  <li><code>-V</code> 自然是查看版本号了, 这里就不多说    </li>
  <li><code>--report</code> 用来查看硬盘的相关配置参数, 不传硬盘的话, 会显示所有硬盘    </li>
  <li>最后一种用法, 就是调用各种命令, 对硬盘进行设置. 或单个参数的查看.</li>
</ul>

<h2 id="report-">report 的内容</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$ </span>blockdev --report
</span><span class="line">RO    RA    SSZ    BSZ    StartSec          Size    Device
</span><span class="line">rw   256    512   4096           0   21474836480    /dev/xvda
</span></code></pre></div></figure></notextile></div>

<p>调用 blockdev 时需要注意使用 <code>root</code> 用户, 或者 <code>sudo</code></p>

<p>现在来看一下这些字段都是些什么含义</p>

<table>
  <tbody>
    <tr>
      <td>字段</td>
      <td>全称</td>
      <td>含义</td>
    </tr>
    <tr>
      <td>RO</td>
      <td>readonly</td>
      <td>硬盘的读写状态. <code>rw</code> 表示可读可写, <code>ro</code> 则表示只读</td>
    </tr>
    <tr>
      <td>RA</td>
      <td>readahead</td>
      <td><code>预读</code> 的大小. Linux 实际大小为 readahead * 2 (KB)</td>
    </tr>
    <tr>
      <td>SSZ</td>
      <td>sector size</td>
      <td>Linux 中<code>扇区</code>(sector) 大小, 单位 <code>byte</code></td>
    </tr>
    <tr>
      <td>BSZ</td>
      <td>block size</td>
      <td>Linux 中<code>块</code>大小 , 单位 <code>byte</code></td>
    </tr>
    <tr>
      <td>StarcSec</td>
      <td>start sector</td>
      <td>当前设备是从第几个 sector 开始的</td>
    </tr>
    <tr>
      <td>Size</td>
      <td>…</td>
      <td>设备的大小, 不支持 -h 参数变得可读 Orz</td>
    </tr>
    <tr>
      <td>Device</td>
      <td>…</td>
      <td>硬盘对应的设备文件</td>
    </tr>
  </tbody>
</table>

<p>想必你现在和我一样, 表格里面的东西看得晕晕乎乎的.</p>

<p>下面我们简单说明一下</p>

<h4 id="section-1">预读</h4>

<p>当 Linux 向磁盘发起 IO 时, 会进行所谓的<code>预读</code>操作.
即, 会比 CPU 操作需要的内容多从读取一小块内容.</p>

<blockquote>
  <p>当然, 如果发现下一次 IO 是随机的, 便会中断当前预读</p>
</blockquote>

<p>而 <code>readahead</code> 项, 就是配置需要提前读取的内容大小</p>

<p>在 tuning<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 数据服务器, 需要关注这个参数  <br />
不过, 一般情况下, 使用默认的 256 (即预读 512KB) 就足够了.</p>

<h4 id="section-2">扇区</h4>

<p><code>扇区</code>是硬盘的物理属性. 也是操作系统读取数据的最小单位.</p>

<h4 id="section-3">块</h4>

<p><code>块</code> 是操作系统在存储文件时的最小单位. 不论文件真实大小, 其占据的硬盘空间一定是块的整数倍.</p>

<p>一个只有一个字符的文件却占据 4K 空间, 就是这个原因</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="bash"><span class="line"><span class="nv">$ </span>cat txt
</span><span class="line">1
</span><span class="line"><span class="nv">$ </span>du -h txt
</span><span class="line">4.0K    txt
</span></code></pre></div></figure></notextile></div>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>不知道怎么翻译好… 有调优的意思, 但又有试探性<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux bash 的 C-s]]></title>
    <link href="http://loudou.info/blog/2014/08/13/linux-bash-de-c-s/"/>
    <updated>2014-08-13T22:22:02+08:00</updated>
    <id>http://loudou.info/blog/2014/08/13/linux-bash-de-c-s</id>
    <content type="html"><![CDATA[<p>putty 莫名不响应问题…</p>

<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">事故</a></li>
  <li><a href="#emacs">缘起 emacs</a></li>
  <li><a href="#c-sc-q">C-s/C-q</a></li>
  <li><a href="#c-s-">取消 C-s 绑定</a></li>
</ul>

<h2 id="section">事故</h2>

<p>在 Windows 下, 一直使用 putty 作为连接远程 Linux 的工具.</p>

<p>偶尔会出现 putty 不响应的现象. 一直不知道是什么问题.  <br />
遇到了也就是重启一下 putty. 也就没有太理会它</p>

<p>今天一次逗[哔]的尝试, 却找到了这个问题的源头:</p>

<blockquote>
  <p>该死的 C-s</p>
</blockquote>

<h2 id="emacs">缘起 emacs</h2>

<p><code>emacs</code> 中 <code>C-s</code> 和 <code>C-r</code> 对应的<code>向下</code>搜索和<code>向上</code>搜索  <br />
而 <code>bash</code> 的编辑快捷键默认采用的便是 emacs 模式.  <br />
便试了试 <code>C-s</code>. 结果出现了不响应的情况.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>搜索到下<a href="http://tianya23.blog.51cto.com/1081650/740207">这篇文章</a></p>

<h2 id="c-sc-q">C-s/C-q</h2>

<p>bash 中 <code>C-s</code> 和 <code>C-q</code> 是代表了一对<code>流控制符</code>.  <br />
其作用就是<code>停止</code>和<code>重启</code>从一个设备向另一个设备的输出流.  <br />
以前是用来切断速率过低的传输过程的(具体有多低, 我也不知道)    </p>

<p>现在的网络比以往要快很多,  <br />
所以这两个控制符也就没什么大用了  <br />
只需要记住, 误敲 <code>C-s</code> 导致 bash 不响应时,    </p>

<blockquote>
  <p>敲下<code>C-q</code> 即可恢复    </p>
</blockquote>

<p>—2014-09-05—</p>

<h2 id="c-s-">取消 C-s 绑定</h2>

<p><code>stty stop undef</code></p>

<p>若要长期生效, 可以写到个人 profile 中</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>bash 中 <code>C-r</code> 仍是<code>向上</code>搜索. 不过,搜索目标是命令历史<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binary Tree Preorder Traversal]]></title>
    <link href="http://loudou.info/blog/2014/08/07/binary-tree-preorder-traversal/"/>
    <updated>2014-08-07T00:50:19+08:00</updated>
    <id>http://loudou.info/blog/2014/08/07/binary-tree-preorder-traversal</id>
    <content type="html"><![CDATA[<p>算法倒是没犯错. 坑在 Python 的一个赋值语法上了</p>

<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">题目</a>    <ul>
      <li><a href="#section-1">翻译</a></li>
    </ul>
  </li>
  <li><a href="#section-2">我的解法</a>    <ul>
      <li><a href="#dsf">迭代式(DSF)</a></li>
      <li><a href="#section-3">递归式</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">题目</h2>

<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>

<p>For example: <br />
Given binary tree {1,#,2,3},</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><pre><code class=""><span class="line">   1
</span><span class="line">    \
</span><span class="line">     2
</span><span class="line">    /
</span><span class="line">   3</span></code></pre></div></figure></notextile></div>

<p>return [1,2,3].</p>

<p>Note: Recursive solution is trivial, could you do it iteratively?</p>

<h3 id="section-1">翻译</h3>

<p>一颗二叉树. 返回按前序遍历排序的节点值列表</p>

<p>例子:
二叉树: {1, #, 2, 3}</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><pre><code class=""><span class="line">   1
</span><span class="line">    \
</span><span class="line">     2
</span><span class="line">    /
</span><span class="line">   3</span></code></pre></div></figure></notextile></div>

<p>返回 [1, 2, 3]</p>

<p>注: 递归式相当简单.试试迭代式?</p>

<h2 id="section-2">我的解法</h2>

<h3 id="dsf">迭代式(DSF)</h3>

<p>最近正好在看图的遍历. 看了下二叉树前序遍历的定义. 自然就想到了用 DSF 算法.  <br />
很快就把代码写好了. 但得到的不是 RunTime Error, 就是 Time Limited Exceeded…</p>

<p>但是, 用 Java 实现却是直接就通过了…(忽略因为不熟 Java 各种类型造成的多次编译错误)</p>

<p>!!!! 还能不能愉快的玩耍了…n</p>

<p>把代码拷到本地调试后发现, 执行过程中 <code>discovered</code> 和 <code>ans</code> 是同一个列表  <br />
回头看我的初始化代码</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">discovered</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
</span></code></pre></div></figure></notextile></div>

<p>明白了…</p>

<p>Python 里面这样的连等赋值是将同一对象坑给不同变量…  <br />
因为以前这样赋值时多是<code>不变量</code>, 所以没什么问题.  <br />
但列表是<code>容器</code>, 所以..就出现了问题</p>

<p>修改初始化</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">discovered</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line"><span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
</span></code></pre></div></figure></notextile></div>

<p>OK, 顺利通过~  <br />
下面是完整代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span><span class="line">    <span class="c"># @param root, a tree node</span>
</span><span class="line">    <span class="c"># @return a list of integers</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
</span><span class="line">        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c"># empty tree</span>
</span><span class="line">            <span class="k">return</span> <span class="p">[]</span>
</span><span class="line">        <span class="n">discovered</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># error type: discovered = ans = []</span>
</span><span class="line">        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line">        <span class="n">discovered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</span><span class="line">        <span class="k">while</span> <span class="n">discovered</span> <span class="o">!=</span> <span class="p">[]:</span>
</span><span class="line">            <span class="n">v</span> <span class="o">=</span> <span class="n">discovered</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</span><span class="line">            <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</span><span class="line">            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
</span><span class="line">                <span class="n">discovered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</span><span class="line">            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
</span><span class="line">                <span class="n">discovered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ans</span>
</span></code></pre></div></figure></notextile></div>

<h3 id="section-3">递归式</h3>

<p>递归式也不是很难. 想清楚 Base Case 好了</p>

<ul>
  <li>Base Case: 以空树作为 Base Case, 返回空列表 <code>[]</code>    </li>
  <li>Recursion: 如果有的话, 依次加上左子树和右子树的前序列表就可以了</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span><span class="line">    <span class="c"># @param root, a tree node</span>
</span><span class="line">    <span class="c"># @return a list of integers</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
</span><span class="line">        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
</span><span class="line">            <span class="k">return</span> <span class="p">[]</span>
</span><span class="line">        <span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>
</span><span class="line">        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
</span><span class="line">            <span class="n">ans</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
</span><span class="line">        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
</span><span class="line">            <span class="n">ans</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ans</span>
</span></code></pre></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Single Number]]></title>
    <link href="http://loudou.info/blog/2014/08/06/single-number/"/>
    <updated>2014-08-06T16:44:56+08:00</updated>
    <id>http://loudou.info/blog/2014/08/06/single-number</id>
    <content type="html"><![CDATA[<p>最近开始撸算法相关的东西. 于是在 LeetCode 上找一些题来练习</p>

<!--more-->

<ul id="markdown-toc">
  <li><a href="#section">题目</a></li>
  <li><a href="#section-1">我的解法</a></li>
  <li><a href="#section-2">大触的解法</a>    <ul>
      <li><a href="#section-3">异或</a></li>
      <li><a href="#section-4">解</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">题目</h2>

<p>第一题还是选择简单点的好了. 选择了一个 AC 率最高的题目.</p>

<p>原题:</p>

<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>

<p>Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>

<p>翻译:</p>

<p>一个整型数组, 其中所有元素都出现了<strong>两次</strong>, 只有一个例外. 找出这个例外</p>

<p>注意:
你的算法的时间复杂度必须是线性的. 能不能不使用额外的空间就实现它?</p>

<h2 id="section-1">我的解法</h2>

<p>使用 Cache 计数. 可以 AC, 但使用了额外空间.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span><span class="line">    <span class="c"># @param A, a list of integer</span>
</span><span class="line">    <span class="c"># @return an integer</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">singleNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
</span><span class="line">        <span class="n">cached</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>  <span class="n">A</span><span class="p">:</span>
</span><span class="line">            <span class="n">cached</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cached</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class="line">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cached</span><span class="p">:</span>
</span><span class="line">            <span class="k">if</span> <span class="n">cached</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span><span class="line">                <span class="k">return</span> <span class="n">i</span>
</span></code></pre></div></figure></notextile></div>

<p>这种方法算是比较通用的通用的解法吧. 重复的元素可以不限制于<strong>两次</strong></p>

<p>也许, 正因为没有利用到<strong>两次</strong>这个条件, 所以才需要使用到额外空间?</p>

<p>如果先排序的话倒是可以通过比较前后两个元素是否相等来寻找唯一元素.</p>

<p>但是目前撸过的排序算法里面就没有线性复杂度的…所以放弃了..</p>

<h2 id="section-2">大触的解法</h2>

<p>之后浏览了下讨论区. 似乎使用 nlg(n) 复杂度的也 AC 了..</p>

<p>不过看到一个相当 trick 的解法 – 使用<code>异或</code>计算<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<h3 id="section-3">异或</h3>

<p>简单说明下异或操作:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>             <span class="c"># 1 -&gt; 0x01 -&gt; 00000001</span>
</span><span class="line"><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>             <span class="c"># 2 -&gt; 0x02 -&gt; 00000010</span>
</span><span class="line"><span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span>         <span class="c"># 3 -&gt; 0x03 -&gt; 00000011</span>
</span></code></pre></div></figure></notextile></div>

<p>把整型数按位进行计算. 同为0或1则得到0, 一个0一个1则得到1
因此得到上面的 <code>1 ^ 2 = 3</code> 的计算</p>

<p>关于异或, 比较特殊的计算</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="n">a</span> <span class="o">^</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class="line"><span class="n">a</span> <span class="o">^</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">a</span>
</span><span class="line"><span class="n">a</span> <span class="o">^</span> <span class="n">b</span> <span class="o">==</span> <span class="n">b</span> <span class="o">^</span> <span class="n">a</span>
</span></code></pre></div></figure></notextile></div>

<p>大触的解法里就用到了上面的公式</p>

<h3 id="section-4">解</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span><span class="line">    <span class="c"># @param A, a list of integer</span>
</span><span class="line">    <span class="c"># @return an integer</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">singleNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
</span><span class="line">        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
</span><span class="line">            <span class="n">ans</span> <span class="o">^=</span> <span class="n">i</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ans</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class="line">    <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span><span class="line">    <span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
</span><span class="line">    <span class="k">print</span> <span class="n">s</span><span class="o">.</span><span class="n">singleNumber</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></code></pre></div></figure></notextile></div>

<p>原理就是上面提到的特殊计算: (2^2) ^ (3^3) ^ (5^5) ^ 4 = 4</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>给大触们跪了 Orz<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[df 与 du 结果不匹配问题]]></title>
    <link href="http://loudou.info/blog/2014/08/04/df-yu-du-jie-guo-bu-pi-pei-wen-ti/"/>
    <updated>2014-08-04T22:03:28+08:00</updated>
    <id>http://loudou.info/blog/2014/08/04/df-yu-du-jie-guo-bu-pi-pei-wen-ti</id>
    <content type="html"><![CDATA[<p>du 与 df 与 文件描述符不得不说的故事</p>

<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">案发现场</a></li>
  <li><a href="#section-1">侦探们</a>    <ul>
      <li><a href="#df">df</a></li>
      <li><a href="#du">du</a></li>
      <li><a href="#lsof">lsof</a></li>
    </ul>
  </li>
  <li><a href="#section-2">真相只有一个</a></li>
  <li><a href="#section-3">现场还原</a></li>
</ul>

<h2 id="section">案发现场</h2>

<p>开发同学接到了 cacti 的预警. 一台生产机器硬盘吃紧, 使用量达到了 90% 以上</p>

<p>这里不方便给截图, 请看官们自行脑补…</p>

<h2 id="section-1">侦探们</h2>

<h3 id="df">df</h3>
<p>首先, 我们派出第一位侦探 <code>df</code>, 以确认被占用的硬盘.</p>

<p><code>df</code> 给出的调查报告如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><pre><code class=""><span class="line">ralph -&gt; df -h
</span><span class="line">Filesystem      Size  Used Avail Use% Mounted on
</span><span class="line">/dev/xvda1       20G   19G  972K 100% /
</span><span class="line">tmpfs           245M     0  245M   0% /dev/shm
</span><span class="line">/dev/xvdb1       40G  6.9G   31G  19% /data</span></code></pre></div></figure></notextile></div>

<p>根据 <code>df</code> 先生的报告, 我们确认被占用的磁盘为 /dev/xvda1, 其挂载目录为 <code>/</code></p>

<h3 id="du">du</h3>

<p>接下来, 该 <code>du</code> 先生出场了, 他会帮我们找到那该死的大文件在哪目录下面的.</p>

<p>我们先看他的第一次报告.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><pre><code class=""><span class="line">ralph -&gt; du --max-depth=1 -h /
</span><span class="line">164K    /dev
</span><span class="line">5.9M    /bin
</span><span class="line">0       /sys
</span><span class="line">4.0K    /mnt
</span><span class="line">18M     /lib64
</span><span class="line">39M     /boot
</span><span class="line">292M    /var
</span><span class="line">603M    /root
</span><span class="line">5.5G    /usr
</span><span class="line">4.0K    /selinux
</span><span class="line">6.7G    /data
</span><span class="line">9.4M    /sbin
</span><span class="line">0       /proc
</span><span class="line">6.6M    /etc
</span><span class="line">75M     /tmp
</span><span class="line">239M    /lib
</span><span class="line">4.0K    /opt
</span><span class="line">4.0K    /media
</span><span class="line">699M    /home
</span><span class="line">20K     /lost+found
</span><span class="line">4.0K    /srv
</span><span class="line">15G     /</span></code></pre></div></figure></notextile></div>

<p>嗯, 从 <code>/</code> 中减掉 <code>/data</code> 目录下的 6.7G. 还有 8.3G.</p>

<p>O_O’’’</p>

<p><code>du</code> !!!! 你玩儿我呢吧… <code>df</code> 已经明确除了 <code>/data</code>, <code>/</code> 目录下应该还有 19G 文件. 是不是不想干了!!!</p>

<h3 id="lsof">lsof</h3>

<p>这时, <code>lsof</code> 主动站出来说话了: 逗逼攻城狮, <em>说不定是有进程在向已删除的文件写数据啊!</em></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><pre><code class=""><span class="line">ralph -&gt; lsof |grep delete
</span><span class="line">grep      12574  ralph  txt       REG  202,1    106232  720903 /bin/grep (deleted)
</span><span class="line">grep      12574  ralph    1u      CHR  136,2       0t0       5 /dev/pts/2 (deleted)
</span><span class="line">grep      12574  ralph    2u      CHR  136,2       0t0       5 /dev/pts/2 (deleted)
</span><span class="line">python    28230  ralph    3w      REG  202,1 734003200  401905 /home/ralph/tmp/write.log (deleted)</span></code></pre></div></figure></notextile></div>

<p>嗯~ 原来如此…杀掉这个 <code>28239</code> 这个 Python 进程后, 磁盘占用恢复正常</p>

<h2 id="section-2">真相只有一个</h2>

<ul>
  <li>
    <p>首先, 在 Linux 系统下, 当一个程序以 <code>写模式</code> 打开一个文件后, 会在进程中保留一个<code>文件描述符</code>, 以便进程对磁盘进行写操作. <code>文件描述符</code> 在 <code>/proc</code> 文件系统下, 表现为一个<code>软链接</code>, 只占用 64 个字节的空间.</p>
  </li>
  <li>
    <p>其次, 而在 Linux 的文件系统中, 我们看到的所谓文件只是一个叫<code>硬链接</code>的东西, 而且可以有多个<code>硬链接</code>指向同一个文件(调..啊不,和 <code>ln</code> 妹纸沟通过就知道). 当指向某一文件块的所有<code>硬链接</code>被删除后, Linux 才会回收对相应磁盘空间的占用</p>
  </li>
</ul>

<p>而此次事件的原因, 正好是<code>文件描述符</code>和<code>硬链接</code>指向同一块磁盘空间造成的.</p>

<p>故事应该是这样发生的:</p>

<ol>
  <li>Python 进程打开了 <code>write.log</code> 的文件描述符, 进行写操作. 但却忘记关闭其描述符   </li>
  <li>Linux 上部署的定时清理程序开始工作, 清理掉了 <code>write.log</code> 文件最后一个硬链接</li>
  <li>因为 Python 进程的文件描述符没有关闭, Linux 内核”不敢”回收这块已经没有硬链接的磁盘空间.</li>
  <li>磁盘空间仍被占用, 但对应目录下却没有<code>文件</code>.</li>
</ol>

<h2 id="section-3">现场还原</h2>

<p>呃, 实际上, 公司的开发语言使用的是 java. 而且, 解决问题时并没有及时截图什么的. 所以, 上面那些数据就是用<code>Python</code> 还原现场时的数据了.</p>

<p>这里再附上 Python 脚本.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line">
</span><span class="line"><span class="n">fobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;write.log&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">whil</span> <span class="bp">True</span><span class="p">:</span>
</span><span class="line">    <span class="n">fobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;*&#39;</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
</span></code></pre></div></figure></notextile></div>

<p>如果不想写太多数据出来, 可以用下面这个版本</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line">
</span><span class="line"><span class="n">fobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;write.log&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">fobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;*&#39;</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class="line">    <span class="k">pass</span>
</span></code></pre></div></figure></notextile></div>

<p>死循环的目的都是为了模拟文件描述符占用</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为 octopress 添加 TOC]]></title>
    <link href="http://loudou.info/blog/2014/08/01/wei-octopress-tian-jia-toc/"/>
    <updated>2014-08-01T00:52:13+08:00</updated>
    <id>http://loudou.info/blog/2014/08/01/wei-octopress-tian-jia-toc</id>
    <content type="html"><![CDATA[<p>添加一个 TOC 方便阅读</p>

<!--more-->

<ul id="markdown-toc">
  <li><a href="#section">尝试</a></li>
  <li><a href="#kramdown-">kramdown 配置</a></li>
  <li><a href="#section-1">在文章中使用</a></li>
  <li><a href="#toc-">让 TOC 飘起来</a></li>
  <li><a href="#section-2">问题什么的</a></li>
</ul>

<h2 id="section">尝试</h2>

<p>开始时尝试了使用默认引擎 <code>rdiscount</code> 的扩展 <code>generate_toc</code>, 但效果并不好.
生成的目录不能进行点击跳转</p>

<p>切换为 <code>kramdown</code> 引擎后, TOC 解析正常.</p>

<h2 id="kramdown-">kramdown 配置</h2>

<p>要切换 <code>kramdown</code>, 只需要修改 <code>_config.yml</code> 文件中的 <code>markdown</code> 属性</p>

<p>如下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>_config.yml</span></figcaption><div class="highlight"><pre><code class="yaml"><span class="line"><span class="l-Scalar-Plain">markdown</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kramdown</span>
</span><span class="line">  <span class="l-Scalar-Plain">toc_levels</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">2..3</span>
</span></code></pre></div></figure></notextile></div>

<p>其中, <code>toc_levels</code> 是用来指定那些标题会进入目录.</p>

<p>因为写作习惯, 我这里就只配置为 h2, h3 进入目录.</p>

<h2 id="section-1">在文章中使用</h2>

<p>完成配置后, 在文章中需要的地方添加以下两行</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>_config.yml</span></figcaption><div class="highlight"><pre><code class="yaml"><span class="line"><span class="err">*</span> <span class="l-Scalar-Plain">any list</span>
</span><span class="line"><span class="l-Scalar-Plain">{:toc}</span>
</span></code></pre></div></figure></notextile></div>

<p><code>kramdown</code> 引擎会帮我们把上面两行按配置解析成 toc, 也就是目录了.</p>

<blockquote>
  <p>如果没有第一行的列表标识的话, kramdown 是不会进行正确的 toc 解析的</p>
</blockquote>

<h2 id="toc-">让 TOC 飘起来</h2>

<p>为了让 TOC 更在阅读的时候更方便, 我们需要修改一下样式</p>

<p>kramdown 解析出来的 TOC 的 id 为 <code>markdown-toc</code>. 所以我们修改样式如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="css"><span class="line"><span class="nf">#markdown</span><span class="nd">:before</span> <span class="p">{</span>
</span><span class="line">    <span class="k">content</span><span class="o">:</span> <span class="s2">&quot;目录&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="k">font-weight</span><span class="o">:</span> <span class="k">bold</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nt">ul</span><span class="nf">#markdown-toc</span> <span class="p">{</span>
</span><span class="line">    <span class="k">list-style</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
</span><span class="line">    <span class="k">position</span><span class="o">:</span> <span class="k">fixed</span><span class="p">;</span>
</span><span class="line">    <span class="k">padding</span><span class="o">:</span> <span class="m">0px</span><span class="p">;</span>
</span><span class="line">    <span class="k">left</span><span class="o">:</span> <span class="m">10px</span><span class="p">;</span>
</span><span class="line">    <span class="k">bottom</span><span class="o">:</span> <span class="m">200px</span><span class="p">;</span>
</span><span class="line">    <span class="k">border</span><span class="o">-</span><span class="n">radius</span><span class="o">:</span> <span class="m">0.3em</span><span class="p">;</span>
</span><span class="line">    <span class="n">box</span><span class="o">-</span><span class="n">shadow</span><span class="o">:</span> <span class="n">rgba</span><span class="p">(</span><span class="m">0</span><span class="o">,</span><span class="m">0</span><span class="o">,</span><span class="m">0</span><span class="o">,</span><span class="m">0</span><span class="o">.</span><span class="m">15</span><span class="p">)</span> <span class="m">0</span> <span class="m">1px</span> <span class="m">4px</span><span class="p">;</span>
</span><span class="line">    <span class="n">box</span><span class="o">-</span><span class="n">sizing</span><span class="o">:</span> <span class="k">border</span><span class="o">-</span><span class="n">box</span><span class="p">;</span>
</span><span class="line">    <span class="k">border</span><span class="o">:</span> <span class="m">#fff</span> <span class="m">0.5em</span> <span class="k">solid</span><span class="p">;</span>
</span><span class="line">    <span class="k">background-color</span><span class="o">:</span> <span class="nb">white</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></div></figure></notextile></div>

<p>这样一个在文章左边悬停的 TOC 就做了好</p>

<h2 id="section-2">问题什么的<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2>

<ul>
  <li>
    <p>kramdown 与 rdiscount 在对 markdown 的部分细节处理上有所不同. 以前的文章也要做调整</p>
  </li>
  <li>
    <p>TOC 的锚, 在跳转时因为 navbar-fixed-top 的问题, 调整 h1~h6 的样式为 {margin-top:-70px;padding-top:70px}.</p>
  </li>
  <li>
    <p>小标题能太长.. 要不会盖到文章正文</p>
  </li>
</ul>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>呃, 为一个 TOC 做到这样. 我也算蛮拼的…<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[无节操地重新认识多态和IoC]]></title>
    <link href="http://loudou.info/blog/2014/07/27/zhong-xin-ren-shi-duo-tai-he-ioc/"/>
    <updated>2014-07-27T23:41:34+08:00</updated>
    <id>http://loudou.info/blog/2014/07/27/zhong-xin-ren-shi-duo-tai-he-ioc</id>
    <content type="html"><![CDATA[<h2 id="section">起源</h2>

<p>源自一则微博:</p>

<p>详情戳<a href="http://weibo.com/1854716251/BfnE2jSR9">这里</a></p>

<!--more-->

<ul id="markdown-toc">
  <li><a href="#section">起源</a></li>
  <li><a href="#ioc-">IoC 简介</a></li>
  <li><a href="#section-1">无节操的例子</a></li>
</ul>

<p>刚转这篇微博的时候, 确实只意识到它用了多态特性.</p>

<p>在自己尝试写一个 Python 版的时候, 才意识到其实这里面更多的在表达 IoC 的设计思路</p>

<h2 id="ioc-">IoC 简介</h2>

<p><code>IoC</code> 的全称是 <code>Inversion of Control</code> 译过来就是控制返转.</p>

<p><a href="http://coolshell.cn/articles/9949.html" title="酷壳">酷壳</a>有一个比较好的例子, 我这里就不重复造轮子了.</p>

<h2 id="section-1">无节操的例子</h2>

<p>这里我们详细谈一下<a href="http://weibo.com/1854716251/BfnE2jSR9" title="PHP版">起源</a>里的例子是怎么回事:</p>

<p>妹子与汉子约会, 会因为汉子的种类(高富帅或diaosi)采取不同行动.</p>

<p>一般的理解思路就是<code>妹子在做选择</code>, 也就是控制权在妹子手里.</p>

<p>这样如果用代码表示的话可能就是下面这样</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">meet</span><span class="p">(</span><span class="n">hanzi</span><span class="p">):</span>
</span><span class="line">   <span class="n">hanzi</span><span class="o">.</span><span class="n">flower</span><span class="p">()</span>
</span><span class="line">   <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hanzi</span><span class="p">,</span> <span class="n">GFS</span><span class="p">):</span>
</span><span class="line">       <span class="k">print</span> <span class="s">&#39;啪啪啪啪啪啪啪啪&#39;</span>
</span><span class="line">   <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hanzi</span><span class="p">,</span> <span class="n">DS</span><span class="p">):</span>
</span><span class="line">       <span class="k">print</span> <span class="s">&#39;啪&#39;</span>
</span></code></pre></div></figure></notextile></div>

<p>而 IoC 的理解思路却是这样的:</p>

<blockquote>
  <p><em>控制权其实在 <code>hanzi</code> 这边, 妹子对汉子的表达是相同的, 但因为 <code>hanzi</code> 的不同而产生了不同结果而已</em></p>
</blockquote>

<p>用代码来表达就是这样</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Meizi</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">meet</span><span class="p">(</span><span class="n">hanzi</span><span class="p">):</span>
</span><span class="line">        <span class="n">hanzi</span><span class="o">.</span><span class="n">flower</span><span class="p">()</span>
</span><span class="line">        <span class="n">hanzi</span><span class="o">.</span><span class="n">chu</span><span class="p">()</span>
</span></code></pre></div></figure></notextile></div>

<p><code>Meizi</code> 这边的代码是不是就变得非常干净了, 那汉子在 chu 之后的结果就不在妹子这里控制了.</p>

<p>至于发生了什么, 我们来看一下 <code>Hanzi</code> 们的具体实现</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Hanzi</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="s">&#39;Abstract class Hanzi&#39;</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">flower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&#39;妹子笑了...&#39;</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">chu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Abstract Method chu not implemented yet&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">GFS</span><span class="p">(</span><span class="n">Hanzi</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">chu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&#39;啪啪啪啪啪啪啪啪&#39;</span>
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">DS</span><span class="p">(</span><span class="n">Hanzi</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">chu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&#39;啪&#39;</span>
</span></code></pre></div></figure></notextile></div>

<p><strong>看, 结果的不同是因为 <code>Hanzi</code> 自己的属性, 而不是妹子的选择.</strong></p>

<p>这就是 IoC 的本质了<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>其实是把妹的本质吧, 喂!!<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
</feed>
