<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: Linux | Test Notes By _漏斗]]></title>
  <link href="http://Ralph-Wang.github.io//blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://Ralph-Wang.github.io/"/>
  <updated>2014-05-11T14:47:48+08:00</updated>
  <id>http://Ralph-Wang.github.io/</id>
  <author>
    <name><![CDATA[_漏斗]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[迂回的监控数据库连接数]]></title>
    <link href="http://Ralph-Wang.github.io/blog/2014/05/09/yu-hui-de-jian-kong-shu-ju-ku-lian-jie-shu/"/>
    <updated>2014-05-09T09:45:51+08:00</updated>
    <id>http://Ralph-Wang.github.io/blog/2014/05/09/yu-hui-de-jian-kong-shu-ju-ku-lian-jie-shu</id>
    <content type="html"><![CDATA[<p>不能通过数据库工具监控到连接数时可用的迂回监控方法</p>

<!--more-->


<h2>原理</h2>

<p>数据库连接底层使用的也是 TCP 协议.</p>

<p>所以当连接到数据库时, 在本地也有打开一个 TCP 端口. 可以通过 nestat 查看</p>

<p>并且每有一个连接, 就会产有一个端口.</p>

<p>所以, 我们只需要数一下 netstat 中打印出来连接到数据库的端口即可</p>

<h2>代码</h2>

<p><div><script src='https://gist.github.com/2c5f64d45de600237f1c.js'></script>
<noscript><pre><code>#!/bin/sh

function echo_db_connect_count()
{
    current_date=`date '+%Y.%m.%d.%H.%M.%S'`
    netstat -an |awk '{gsub(&quot;::ffff:&quot;,&quot;&quot;); print $5}'|grep &quot;$port&quot; |sort | uniq -c |sed &quot;s/^/$current_date/g&quot;
}

port=$1
step=$2

if [ &quot;$port&quot; == &quot;&quot; ];then
    exit 1
fi

if [ &quot;$step&quot; == &quot;&quot; ];then
    step=1
fi


while true
do
    echo_db_connect_count $port
    sleep $step
done
</code></pre></noscript></div>
</p>

<h2>命令分析</h2>

<p>核心就一行, 摘出来看看:</p>

<p><code>bash
netstat -an |awk '{gsub("::ffff:",""); print $5}'|grep "$port" |sort | uniq -c
|sed "s/^/$current_date/g"
</code></p>

<p>各个命令在干什么:</p>

<p><code>netstat</code> 不多说, 打印出所有打开着的端口</p>

<p><code>awk</code> 在这里做一步初步处理, gsub(&ldquo;::ffff:&rdquo;, &ldquo;&rdquo;), 是为了去除 ipv6 格式的 ip 地址.</p>

<p><code>grep</code> 就是为了过滤出想监控的端口号</p>

<p><code>sort</code> 让所有打印出来的远程连接排序, 为下一步 uniq 作铺垫</p>

<p><code>uniq</code> 去重, <code>-c</code> 计算重复的项. 这样就得到连接的总数了</p>

<p><code>sed</code> 既然是监控, 在行首添加上时间.</p>

<p>执行结果的样例:</p>

<p><img src="/blogimgs/net_watch.png" alt="net_watch" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分析一个 Linux 命令]]></title>
    <link href="http://Ralph-Wang.github.io/blog/2014/04/14/fen-xi-yi-ge-linux-ming-ling/"/>
    <updated>2014-04-14T22:44:14+08:00</updated>
    <id>http://Ralph-Wang.github.io/blog/2014/04/14/fen-xi-yi-ge-linux-ming-ling</id>
    <content type="html"><![CDATA[<p>通过拆解查看 CPU 信息的组合命令, 来学习每个独立命令</p>

<!--more-->


<h2>查看 CPU 型号及数量</h2>

<p>原命令
```bash</p>

<h1>cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</h1>

<p>```
cat 和 grep 就不多说了</p>

<h3>cut:</h3>

<p>help 中的说明是 <strong> Print selected parts of lines from each FILE to standard
output </strong> .  输出所有选中的行</p>

<p><code>-f2</code> 是选中第二列, 换成<code>--fields=2</code>也是可以的.</p>

<p><code>-d:</code> 则表示用冒号作为列分割符, 等价于<code>--delimiter=:</code></p>

<p><strong>其它选项:</strong></p>

<p><code>-s</code> 不包含分割符的不输出</p>

<h3>uniq:</h3>

<p>man 中的说明 <strong> report or omit repeated lines </strong> . 实际就是去除重复行</p>

<p><code>-c</code> 表示在输出行前加上其在原文件中出现的次数</p>

<p><strong>其它选项:</strong></p>

<p><em>和输出相关:</em></p>

<p><code>-d</code> 只输出发生了重复的行. <em>04-24 更新:</em> 重复行只输出一行</p>

<p><code>-D</code> 只输出发生了重复的行. 但输出所有重复行.</p>

<p><code>-u</code> 只输出唯一行</p>

<p><em>和比较相关:</em></p>

<p><code>-fN</code> 前N列不比较. 以空格或TAB为列分割符</p>

<p><code>-sN</code> 前N个字符不比较</p>

<p><code>-wN</code> 最多比较N个字符</p>

<p><code>-i</code> 无视大小写差别. A 与 a 视为一致</p>

<p><em>其它:</em></p>

<p><code>-z</code> 以 0 作为行末</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 awk 查看 PATH 环境变量]]></title>
    <link href="http://Ralph-Wang.github.io/blog/2014/03/06/yong-awk-cha-kan-path-huan-jing-bian-liang/"/>
    <updated>2014-03-06T14:18:22+08:00</updated>
    <id>http://Ralph-Wang.github.io/blog/2014/03/06/yong-awk-cha-kan-path-huan-jing-bian-liang</id>
    <content type="html"><![CDATA[<!--more-->


<p>查看 PATH 环境变量是件痛苦的事情.</p>

<p>用 <code>echo</code> 直接显示时, 输出只有一行, 查看起来很费神</p>

<p>如下图
<code>bash
$echo $PATH
</code></p>

<p><img src="/blogimgs/path-normal.png" alt="path normal" /></p>

<p>看 <code>awk</code> 用法时, 记得可以用 <code>RS</code> 变量修改行标识, 于是试试</p>

<p><code>bash
$echo $PATH | awk 'BEGIN {RS=":"} {print $0}'
</code></p>

<p><img src="/blogimgs/path-withawk.png" alt="path with awk" /></p>

<p>确实清晰不少.</p>

<hr />

<h4>2014-05-11 更新</h4>

<p>今天才发现, 其实有更简单的办法&hellip; Orz
<code>bash
echo $PAHT |tr : '\n'
</code></p>
]]></content>
  </entry>
  
</feed>
