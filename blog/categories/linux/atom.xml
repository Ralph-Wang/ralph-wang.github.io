<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: Linux | 挨踢夜归人]]></title>
  <link href="http://ralph-wang.github.io//blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://ralph-wang.github.io/"/>
  <updated>2014-08-07T01:44:03+08:00</updated>
  <id>http://ralph-wang.github.io/</id>
  <author>
    <name><![CDATA[_漏斗]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[df 与 du 结果不匹配问题]]></title>
    <link href="http://ralph-wang.github.io/blog/2014/08/04/df-yu-du-jie-guo-bu-pi-pei-wen-ti/"/>
    <updated>2014-08-04T22:03:28+08:00</updated>
    <id>http://ralph-wang.github.io/blog/2014/08/04/df-yu-du-jie-guo-bu-pi-pei-wen-ti</id>
    <content type="html"><![CDATA[<p>du 与 df 与 文件描述符不得不说的故事</p>

<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">案发现场</a></li>
  <li><a href="#section-1">侦探们</a>    <ul>
      <li><a href="#df">df</a></li>
      <li><a href="#du">du</a></li>
      <li><a href="#lsof">lsof</a></li>
    </ul>
  </li>
  <li><a href="#section-2">真相只有一个</a></li>
  <li><a href="#section-3">现场还原</a></li>
</ul>

<h2 id="section">案发现场</h2>

<p>开发同学接到了 cacti 的预警. 一台生产机器硬盘吃紧, 使用量达到了 90% 以上</p>

<p>这里不方便给截图, 请看官们自行脑补…</p>

<h2 id="section-1">侦探们</h2>

<h3 id="df">df</h3>
<p>首先, 我们派出第一位侦探 <code>df</code>, 以确认被占用的硬盘.</p>

<p><code>df</code> 给出的调查报告如下</p>

<p><code>
ralph -&gt; df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/xvda1       20G   19G  972K 100% /
tmpfs           245M     0  245M   0% /dev/shm
/dev/xvdb1       40G  6.9G   31G  19% /data
</code></p>

<p>根据 <code>df</code> 先生的报告, 我们确认被占用的磁盘为 /dev/xvda1, 其挂载目录为 <code>/</code></p>

<h3 id="du">du</h3>

<p>接下来, 该 <code>du</code> 先生出场了, 他会帮我们找到那该死的大文件在哪目录下面的.</p>

<p>我们先看他的第一次报告.</p>

<p><code>
ralph -&gt; du --max-depth=1 -h /
164K    /dev
5.9M    /bin
0       /sys
4.0K    /mnt
18M     /lib64
39M     /boot
292M    /var
603M    /root
5.5G    /usr
4.0K    /selinux
6.7G    /data
9.4M    /sbin
0       /proc
6.6M    /etc
75M     /tmp
239M    /lib
4.0K    /opt
4.0K    /media
699M    /home
20K     /lost+found
4.0K    /srv
15G     /
</code></p>

<p>嗯, 从 <code>/</code> 中减掉 <code>/data</code> 目录下的 6.7G. 还有 8.3G.</p>

<p>O_O’’’</p>

<p><code>du</code> !!!! 你玩儿我呢吧… <code>df</code> 已经明确除了 <code>/data</code>, <code>/</code> 目录下应该还有 19G 文件. 是不是不想干了!!!</p>

<h3 id="lsof">lsof</h3>

<p>这时, <code>lsof</code> 主动站出来说话了: 逗逼攻城狮, <em>说不定是有进程在向已删除的文件写数据啊!</em></p>

<p><code>
ralph -&gt; lsof |grep delete
grep      12574  ralph  txt       REG  202,1    106232  720903 /bin/grep (deleted)
grep      12574  ralph    1u      CHR  136,2       0t0       5 /dev/pts/2 (deleted)
grep      12574  ralph    2u      CHR  136,2       0t0       5 /dev/pts/2 (deleted)
python    28230  ralph    3w      REG  202,1 734003200  401905 /home/ralph/tmp/write.log (deleted)
</code></p>

<p>嗯~ 原来如此…杀掉这个 <code>28239</code> 这个 Python 进程后, 磁盘占用恢复正常</p>

<h2 id="section-2">真相只有一个</h2>

<ul>
  <li>
    <p>首先, 在 Linux 系统下, 当一个程序以 <code>写模式</code> 打开一个文件后, 会在进程中保留一个<code>文件描述符</code>, 以便进程对磁盘进行写操作. <code>文件描述符</code> 在 <code>/proc</code> 文件系统下, 表现为一个<code>软链接</code>, 只占用 64 个字节的空间.</p>
  </li>
  <li>
    <p>其次, 而在 Linux 的文件系统中, 我们看到的所谓文件只是一个叫<code>硬链接</code>的东西, 而且可以有多个<code>硬链接</code>指向同一个文件(调..啊不,和 <code>ln</code> 妹纸沟通过就知道). 当指向某一文件块的所有<code>硬链接</code>被删除后, Linux 才会回收对相应磁盘空间的占用</p>
  </li>
</ul>

<p>而此次事件的原因, 正好是<code>文件描述符</code>和<code>硬链接</code>指向同一块磁盘空间造成的.</p>

<p>故事应该是这样发生的:</p>

<ol>
  <li>Python 进程打开了 <code>write.log</code> 的文件描述符, 进行写操作. 但却忘记关闭其描述符   </li>
  <li>Linux 上部署的定时清理程序开始工作, 清理掉了 <code>write.log</code> 文件最后一个硬链接</li>
  <li>因为 Python 进程的文件描述符没有关闭, Linux 内核”不敢”回收这块已经没有硬链接的磁盘空间.</li>
  <li>磁盘空间仍被占用, 但对应目录下却没有<code>文件</code>.</li>
</ol>

<h2 id="section-3">现场还原</h2>

<p>呃, 实际上, 公司的开发语言使用的是 java. 而且, 解决问题时并没有及时截图什么的. 所以, 上面那些数据就是用<code>Python</code> 还原现场时的数据了.</p>

<p>这里再附上 Python 脚本.</p>

<p>```python
#!/usr/bin/env python</p>

<p>fobj = open(‘write.log’, ‘w’)</p>

<p>whil True:
    fobj.write(‘*’ * 1024 * 1024)
```</p>

<p>如果不想写太多数据出来, 可以用下面这个版本</p>

<p>```
#!/usr/bin/env python</p>

<p>fobj = open(‘write.log’, ‘w’)</p>

<p>fobj.write(‘*’ * 1024 * 1024)</p>

<p>while True:
    pass
```</p>

<p>死循环的目的都是为了模拟文件描述符占用</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning the Bash Shell 笔记-Debug]]></title>
    <link href="http://ralph-wang.github.io/blog/2014/06/11/learning-the-bash-shell-bi-ji-debug/"/>
    <updated>2014-06-11T10:40:33+08:00</updated>
    <id>http://ralph-wang.github.io/blog/2014/06/11/learning-the-bash-shell-bi-ji-debug</id>
    <content type="html"><![CDATA[<p>任何开发测试工作都离不开的话题 – Debug. </p>

<p>bash 脚本自然也不能免俗
<!--more--></p>

<h2 id="section">显示每一步执行的命令</h2>

<p>默认情况下, bash 脚本执行时不会像 Windows 的 bat 一样显示每一次执行的命令.
虽然说这功能在执行时比较难看, 但在 Debug
时可以帮助我们查看脚本是执行到哪一行出现的问题</p>

<p>如果想让 bash 脚本运行时显示每行命令, 则需要在脚本开始添加如下命令:</p>

<p><code>bash
set -o [noexec|verbose|xtrace]
</code></p>

<p>参数说明:</p>

<ul>
  <li>
    <p><code>noexec</code>	不执行脚本, 只检查语法错误</p>
  </li>
  <li>
    <p><code>verbose</code>	显示每一行命令 (开启这个功能后 bash 就和 bat 很像了)</p>
  </li>
  <li>
    <p><code>xtrace</code>	比 verbose 更详细的显示, 具体显示信息由 <code>PS4</code> 变量配置</p>
  </li>
</ul>

<h2 id="fake-signal">几个 fake signal</h2>

<h3 id="exit">EXIT</h3>

<p>在脚本退出时会触发该信号</p>

<p>```bash exit.sh
#!/bin/sh</p>

<p>trap ‘echo exiting the script’ EXIT</p>

<p>echo ‘starting the script’
```</p>

<p>执行结果:</p>

<p><code>bash
$./exit.sh
starting the script
exiting the script
</code></p>

<h3 id="debug">DEBUG</h3>

<p>每一行命令执行前都会触发这个信号, 开启 <code>set -o functrace</code> 后函数内部也会触发</p>

<p>```bash debug.sh
#!/bin/sh</p>

<p>trap ‘echo execute $LINENO’ DEBUG</p>

<p>for ((_i=0;_i&lt;2;_i++))
do
echo $_i
done
```</p>

<p>执行结果:</p>

<p><code>bash
$./debug.sh
execute 5
execute 5
execute 7
0
execute 5
execute 5
execute 7
1
execute 5
execute 5
</code></p>

<h3 id="err">ERR</h3>
<p>当有命令执行后的返回值不是 0 时触发该信号</p>

<p>```bash err.sh
#!/bin/sh</p>

<p>trap ‘echo Error with status $?’ ERR</p>

<p>function bad
{
	return 111
}</p>

<p>bad
```</p>

<p>执行结果</p>

<p><code>bash
$./err.sh
Error with status 111
</code></p>

<h3 id="return">RETURN</h3>
<p>当用 <code>source</code> 执行脚本返回后触发该信号</p>

<p>若执行 <code>set -o functrace</code>, 则函数返回后也能触发该信号</p>

<p><code>bash x.sh
echo "Hello World"
</code></p>

<p>```bash return.sh
#!/bin/sh
trap ‘echo debug occured’ DEBUG
trap ‘echo return occured’ RETURN</p>

<p>source ./x.sh
```</p>

<p>执行结果</p>

<p><code>bash
debug occured
Hello World
return occured
</code></p>

<h2 id="debugger">一个简易的 Debugger</h2>

<p>一个 Debugger 需要的功能点:</p>

<ul>
  <li>
    <p>断点</p>
  </li>
  <li>
    <p>逐步执行</p>
  </li>
  <li>
    <p>变量监视</p>
  </li>
  <li>
    <p>显示当前执行位置和断点位置</p>
  </li>
  <li>
    <p>不需要改动源码即可进行 Debug</p>
  </li>
</ul>

<h2 id="section-1">实现原理:</h2>
<p>利用 <code>DEBUG</code> 信号中断执行. 进而进入 debug 命令行</p>

<h2 id="section-2">核心数组:</h2>
<ul>
  <li>
    <p><code>_lines</code> 用来存储所有 Debug 脚本的代码</p>
  </li>
  <li>
    <p><code>_linebp</code> 用来存储断点行号</p>
  </li>
</ul>

<p>文件结构:</p>

<blockquote>
  <p>bashdb  # 主脚本, 即驱动器</p>
</blockquote>

<blockquote>
  <p>bashdb.pre # 添加到原脚本头的部分</p>
</blockquote>

<blockquote>
  <p>bashdb.fns # 定义的函数们</p>
</blockquote>

<p>```bash bashdb
#!/bin/sh</p>

<p>_dbname=${0##*/}
echo ‘Bash Debugger Version 1.0’</p>

<p>if (( $# &lt; 1 ))
then
	echo “$_dbname Usage: $_dbname filename.” &gt;&amp;2
	exit 1
fi</p>

<p>_guineapig=$1</p>

<p>if [ -r $_guineapig ]
then
	echo “$_dbname: file ‘$1’ is not readable.” &gt;&amp;2
	exit 1
fi</p>

<p>shift</p>

<p>_tmpdir=/tmp
_libdir=.
_debugfile=$_tmpdir/bashdb.$$ # tmp file for script debugged</p>

<p>cat $_libdir/bashdb.pre $_guineapig &gt; $_debugfile
exec bash $_debugfile $_guineapig $_tmpdir $_libdir “$@”
```</p>

<blockquote>
  <p>关于 <code>exec</code> 命令
&gt; 执行其参数, 用其并替代当前进程. 脚本中在 <code>exec</code> 后的命令都不会执行
&gt; 在 cli 中执行 exec 后… 当前 shell 会直接退出</p>
</blockquote>

<p>```bash bashdb.pre
#!/bin/sh</p>

<p>_debugfile=$0
_guineapig=$1</p>

<p>_tmpdir=$2
_libdir=$3</p>

<p>shift 3</p>

<h1 id="section-3">将所有函数加载进来</h1>
<p>source $_libdir/bashdb.fns</p>

<p>_linebp=
let _trace=0
let _i=0</p>

<p>{
	while read
	do
		_line[$_i]=$REPLY
		let _i=$_i+1
	done
} &lt; $_guineapig</p>

<h1 id="section-4">退出时清除临时文件</h1>
<p>trap _cleanup EXIT</p>

<p>let _steps=1</p>

<h1 id="bashdbpre-">减掉 bashdb.pre 的行数</h1>
<p>trap ‘_steptrap $(($LINENO - 32))’ DEBUG
```</p>

<p>```bash bashdb.fns
#!/bin/sh</p>

<h1 id="debugger--steptrap">Debugger 的主要函数 _steptrap</h1>
<p># 每一行代码执行前, 这个函数都会被调用</p>

<p>function _steptrap
{
	_curlline=$1
	(( $trace )) &amp;&amp; _msg “Line $_curlline: ${_lines[$_curlline]}”</p>

<pre><code>if (( $_steps &gt;= 0 ))
then
	let _steps=$_steps-1
fi

# check if there is a breakpoint
if _at_linenumbp
then
	_msg "Reached breakpoint at $_curlline"
	_cmdloop
fi

# check if there is a break condition
if [ -n "$_brcond" ] &amp;&amp; eval $_brcond 
then
	_msg "Break condition $_brcond true at line $_curlline"
	_cmdloop

# check if there are no more steps
if (( $_steps == 0 ))
then
	_msg "Stopped at line $_curlline"
	_cmdloop
fi }
</code></pre>

<h1 id="cmdloop">命令处理函数 _cmdloop</h1>

<p>function _cmdloop
{
	local cmd args</p>

<pre><code>while read -e -p "bash&gt; " cmd args
do
	case $cmd in
		\?|h ) # 显示命令菜单
			_menu ;;
		bc ) # 设置中断条件
			_setbc $args ;;
		bp ) # 设置断点
			_setbp $args ;;
		cb ) # 清除一个或全部断点
			_clearbp $args ;;
		ds ) # 显示脚本和断点
			_displayscript ;;
		g ) # 运行脚本直到断点
			return ;;
		q ) # 退出
			exit ;;
		s ) # 执行 N 行, 默认 1 行
			let _steps=${args:-1}
		x ) # 开关显示所在行
			_xtrace ;;
		!* ) # 执行 shell 命令
			eval ${cmd#!} $args;;
		* )
			_msg "Invalid command: '$cmd'" ;;
	esac
done }
</code></pre>

<h1 id="setbp">设置断点命令对应函数 _setbp</h1>

<p>functrace _setbp
{
	# 没有参数就显示断点信息
	if [ -z “$1” ]
	then
		_listbp
	elif [ $(echo $1 | grep ‘^[0-9]*’) ]
	then
		if [ -n “${list[$1]” ]
		then # 将新断点与旧断点重新排序放入 _linebp
			_linebp=($(echo $( (for i in ${_linebp[@]} $1;do
			echo $i; done) | sort -n) ))
		else # 空行不能设置断点
			_msg “Breakpoints can only be set on non-blank lines”
		fi
	else
		_msg “Please specify a numeric line number”
	fi
}</p>

<h2 id="section-5">其它函数这里省略</h2>
<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning the Bash Shell 笔记-杂项]]></title>
    <link href="http://ralph-wang.github.io/blog/2014/06/05/learning-the-bash-shell-bi-ji-za-xiang/"/>
    <updated>2014-06-05T09:49:16+08:00</updated>
    <id>http://ralph-wang.github.io/blog/2014/06/05/learning-the-bash-shell-bi-ji-za-xiang</id>
    <content type="html"><![CDATA[<p>一些零散的内容
<!--more-->
## getopts
getopts 主要用来定义和解析脚本支持的命令行选项.</p>

<p>简单用法如下:</p>

<p>```bash
while getopts “:ab:c” opt
do
	case $opt in
		a )
			statements for -a
			;;
		b )
			$OPTARG is the argument value of -b
			statements for -b
			;;
		c )
			statements for -c
			;;
		\? )
			other
	esac
done</p>

<p>shift $(($OPTIND - 1))</p>

<p>main scripts
```</p>

<ul>
  <li>
    <p>getopts 第一个字符串中声明支持的选项名 (只能单字符);
如果字符后面加有冒号(:)则表示该选项有对应的选项参数,
参数值会保存到变量<code>OPTARG</code>中</p>
  </li>
  <li>
    <p>执行过 getopt 后, 会在变量<code>OPTIND</code>中保存 (选项+选项参数) 的总个数. 用 shift $(($OPTIND - 1)) 来确保后续代码不受实际选项个数影响</p>
  </li>
  <li>
    <p>在声明所支持的选项时, 如果以冒号(:)开头, 可以忽略传入不合法的选项</p>
  </li>
</ul>

<h2 id="shell--make">shell 实现极简 make</h2>
<p>没有变量支持什么, 只是解释命令和依赖</p>

<p>```
#!/bin/sh</p>

<h1 id="set--o-verbose">set -o verbose</h1>

<p>makecmd()
{
    read target colon sources
    for src in $sources
    do
        if [ $src -nt $target ]
        then
            while read cmd
            do
                echo “$cmd”
                eval ${cmd#\t}
            done
            break
        fi
    done
}</p>

<p>makecmd &lt; Makefile
```</p>

<ul>
  <li>
    <p>只能处理一个命令, 不支持变量什么的</p>
  </li>
  <li>
    <p>用 read 从标准输入中读取 target colon sources</p>
  </li>
  <li>
    <p>循环判断 sources 中各依赖与 target 修改日期; <code>FILE1 -nt FIlE2</code>, <code>FILE1 -ot
FILE2</code> 用来比较两个文件修改时间</p>
  </li>
  <li>
    <p>eval “string” 将 string 作为 bash 命令解析</p>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning the Bash Shell 笔记-流控制]]></title>
    <link href="http://ralph-wang.github.io/blog/2014/05/22/learning-the-bash-shell-bi-ji-liu-kong-zhi/"/>
    <updated>2014-05-22T21:19:21+08:00</updated>
    <id>http://ralph-wang.github.io/blog/2014/05/22/learning-the-bash-shell-bi-ji-liu-kong-zhi</id>
    <content type="html"><![CDATA[<p>但凡是代码就逃不开的流控制话题
<!--more--></p>

<h2 id="section">条件</h2>

<p>bash 中的条件值以数字 0 表示真, 非0 则为假, 并不存在布尔类型</p>

<p>其中有三种条件形式可以得到条件值</p>

<h3 id="section-1">命令的退出状态</h3>
<p>一般来说, Linux 的命令若执行成功, 则退出状态为 0, 不成功则返回 1-255</p>

<blockquote>
  <p><em>diff 命令除外, diff 返回 0 表示两个文件没有差别, 1 表示有差别, 2+
表示发生错误</em></p>
</blockquote>

<h3 id="section-2">脚本或函数的返回值</h3>

<p>在脚本或函数中, 用 return 表示结束并返回</p>

<p>当然, 在 bash 中只能返回数字类型, 返回字符串的话脚本会出错</p>

<p>另外, return 写返回值的话, 默认返回 0</p>

<blockquote>
  <p>脚本或函数中若没有用 return 返回值时, 则以最后一条命令的退出状态作为返回值</p>
</blockquote>

<h3 id="test">测试 test</h3>

<p>bash 中测试有两种写法</p>

<ul>
  <li>test condition</li>
  <li>[ condition ] <em>[ ] 两个方括号和中间条件之间必须要有一个空格</em></li>
</ul>

<p>两种写法是等价的, 详细的写法可参考 <code>man test</code></p>

<h2 id="ifelifelse">if..elif..else</h2>

<p><code>bash
if condition
then
	statements
[elif condition
then
	statements]
[else
	statements]
fi
</code></p>

<h2 id="case">case</h2>

<p><code>bash
case epxr in
	pattern1 )
		statements
		;;
	pattern2 )
		statements
		;;
	...
esac
</code>
<em>pattern1/2</em> 支持 bash 的通配符, 也支持 | 来表示多模式匹配</p>

<p><code>;;</code> 类似于其它语言中的 break</p>

<p>因为匹配是从上到下的, 所以可以用 <code>*)</code> 来表示 default</p>

<h2 id="select">select</h2>

<p><code>bash
select case [in caselist]
do
	statements about $case
	[break]
done
</code></p>

<p>用 caselist 里的所有项生成一个简单的选择菜单</p>

<p>statements 中 $case 就是选择的项</p>

<p>完成一次 statements 后, 若没有遇到 break 则会继续下一次 select</p>

<h2 id="for">for</h2>

<p><code>bash
for ((expr1;expr2;expr3))
	statements
end
</code></p>

<p>这个比较类似 Java 里的 for</p>

<p><code>bash
for i [in list]
do
	statements
done
</code></p>

<p>这个感觉更像 python 里的 for</p>

<p>若省略 [in list] 的话, 则默认从 $@ 中取值</p>

<p><code>bash
for i in {start..end..step}
do
	statements
done
</code>
bash 4.0 以上才有的语法</p>

<h2 id="while--until">while &amp; until</h2>

<p><code>bash
while condition
do
	statements
done
</code></p>

<p><code>bash
until condition
do
	statements
done
</code></p>

<p>while condition 等价于 until ! condition</p>

<p>两者没有其它区别</p>

<h2 id="section-3">附:</h2>
<p>又一个友好地显示 PATH 的方法</p>

<p>```bash showpath.sh
path=$PATH</p>

<p>while [ $path ];
do
	echo ${path%%:<em>}
	echo ${path#</em>:}
done
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning The Bash Shell 笔记-变量]]></title>
    <link href="http://ralph-wang.github.io/blog/2014/05/15/learning-the-bash-shell-du-shu-bi-ji-bian-liang/"/>
    <updated>2014-05-15T09:35:19+08:00</updated>
    <id>http://ralph-wang.github.io/blog/2014/05/15/learning-the-bash-shell-du-shu-bi-ji-bian-liang</id>
    <content type="html"><![CDATA[<!--more-->

<h2 id="section">$* 和 $@</h2>
<p>这两个变量都可以得到脚本运行得到的所有参数.</p>

<p>默认情况下, 这两个变量没有区别</p>

<p>```bash sample.sh
#!/bin/bash</p>

<p>echo $*</p>

<p>echo $@
```</p>

<p>运行上面的脚本, 传入多个参数. 得到的两行输出结果是一样的.</p>

<p><code>bash
$./sample.sh 1 2 3
1 2 3
1 2 3
</code></p>

<p>但是, 当给变量 IFS(internal field sperator) 赋上值并用双引号将 <code>$*</code> 和 <code>$@</code>
括起来, 情况就不一样了.</p>

<p>```bash sample2.sh
#!/bin/bash</p>

<p>IFS=,</p>

<p>echo “$*”</p>

<p>echo “$@”
```</p>

<p>这时候, 在 <code>$*</code> 中不再是以空格分割所有参数, 而是由 IFS 的值 (当前脚本中为逗号)来分割</p>

<p>而 <code>$@</code> 则保持原样</p>

<p><code>bash
$./sample2.sh 1 2 3
1,2,3
1 2 3
</code></p>

<p>当用双引号括起来以后, <code>"$*"</code> 等价于 <code>"$1$IFS$2$IFS$3...$IFS$N"</code></p>

<p>而 <code>"$@"</code> 等价于 <code>"$1" "$2" "$3"... "$N"</code></p>

<h2 id="string-operator">String Operator</h2>

<p>对于 shell 变量, 还有一些操作符可以让脚本变得更活</p>

<ul>
  <li>
    <p><code>${var:-word}</code>: 如果 var 变量不存在或为 null, 则返回 word. var 变量仍然不存在或为 null</p>
  </li>
  <li>
    <p><code>${var:=word}</code>: 如果 var 变量不存在或为 null, 则将 word 赋值给 var, 并返回 var 的新值(word)</p>
  </li>
  <li>
    <p><code>${var:?msg}</code>: 如果 var 变量不存在或为 null, 则停止脚本, 并输出信息 <strong>var: msg</strong></p>
  </li>
  <li>
    <p><code>${var:+word}</code>: 如果 var 变量存在并不为 null, 则返回 word. 否则, 返回 null</p>
  </li>
  <li>
    <p><code>${var:offset:length}</code> 截取变量 var 从 offset 开始长度为 length 的字符串.  offset 从 0 开始. length 为 null 截取剩余全部.</p>
  </li>
</ul>

<p>```bash sample3.sh
#!/bin/bash</p>

<p>echo ${var:-“minus”}</p>

<p>echo ${var}</p>

<p>echo ${var:=”equals”}</p>

<p>echo ${var}</p>

<p>echo ${var:+”plus”}</p>

<p>echo ${var:2:2} #output ua</p>

<p>echo ${theVar:?”should not be empty”}
```</p>

<p>输出:</p>

<p>```
minus</p>

<p>equals
equals
plus
ua
sample3.sh: line 15: theVar: should not be empty
```</p>

<h2 id="section-1">一个练习</h2>
<p>你收集了一专辑, 并已经统计出了不同歌手的专辑数量, 现在需要找出收集数量前 10 的歌手. 文件格式如下:</p>

<p><code>text file
5 Depeche Mode
2 Split Enz
3 Simple Minds
1 Vivaldi, Antonio
</code></p>

<p>ok, 实现代码很简单 <code>sort -nr file | head -n 10</code></p>

<p>不过, 书中的解答不得不说更好</p>

<p>```bash
#!/bin/bash</p>

<p>filename=${1:?”filename missing”}
howmany=${2:-10}</p>

<p>sort -nr $filename | head -n $howmany
```</p>

<p>这样脚本化之后, 增加了可读性, 而且也不限于统计前 10.</p>
]]></content>
  </entry>
  
</feed>
