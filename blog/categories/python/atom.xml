<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: Python | 挨踢夜归人]]></title>
  <link href="http://blog.loudou.info//blog/categories/python/atom.xml" rel="self"/>
  <link href="http://blog.loudou.info/"/>
  <updated>2015-07-21T11:33:01+08:00</updated>
  <id>http://blog.loudou.info/</id>
  <author>
    <name><![CDATA[_漏斗]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用生成器进行惰性读取]]></title>
    <link href="http://blog.loudou.info/blog/2015/07/21/shi-yong-sheng-cheng-qi-jin-xing-duo-xing-du-qu/"/>
    <updated>2015-07-21T10:47:10+08:00</updated>
    <id>http://blog.loudou.info/blog/2015/07/21/shi-yong-sheng-cheng-qi-jin-xing-duo-xing-du-qu</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">需求</a></li>
  <li><a href="#section-1">错误的实现</a></li>
  <li><a href="#section-2">正确的实现</a></li>
  <li><a href="#tips">tips</a></li>
</ul>

<h2 id="section">需求</h2>

<p>完成一个函数, 从文件中读取数据并按行解析</p>

<h2 id="section-1">错误的实现</h2>

<p><code>python
def items(file_name):
    l = []
    for line in open(file_name):
        l.append(parse(line))
    return l
</code></p>

<p>这样实现会将文件全部读入内存后才能返回所有解析好的数据列表,
在处理大文件时会变得非常慢,非常慢,非常慢</p>

<h2 id="section-2">正确的实现</h2>

<p><code>
def items(file_name):
    for line in open(file_name):
        yield parse(line)
</code></p>

<p>使用生成器的方式, 可以保留 open 提供的惰性读取特性, 使得内存占用很小</p>

<h2 id="tips">tips</h2>

<p>当需要同时读取两个文件时, 不要使用 <code>for i, j in zip(a, b)</code> 去处理, 因为 zip
需要把 a, b 全部读入, 这样破坏了惰性读取的特性.</p>

<p>正确的做法:</p>

<p><code>
f1 = items(file_name1)
f2 = items(file_name2)
while True:
    try:
        i = f1.next()
        j = f2.next()
    except StopIteration:
        break
</code></p>

<p>主动调用生成器的 next 方法可以在使用多个生成器时保留其惰性.</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[装饰器与多进程以及Pickle]]></title>
    <link href="http://blog.loudou.info/blog/2015/02/15/zhuang-shi-qi-yu-duo-jin-cheng-yi-ji-pickle/"/>
    <updated>2015-02-15T21:39:08+08:00</updated>
    <id>http://blog.loudou.info/blog/2015/02/15/zhuang-shi-qi-yu-duo-jin-cheng-yi-ji-pickle</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">缘起</a></li>
  <li><a href="#section-1">解答</a></li>
  <li><a href="#section-2">分析</a></li>
</ul>

<h2 id="section">缘起</h2>

<p>因为需要并发请求同时计时, 写上如下代码:</p>

<p>```python
def timer(func):
    def _wrap(<em>args):
        start = time.time()
        ret = func(</em>args)
        return ret, time.time() - start
    return _wrap</p>

<p>@timer
def get(url):
    return requests.get(url)</p>

<p>rets = []
for i in xrange(10):
    rets.append(pool.apply_async(get, (url,)))
for ret in rets:
    ret.get()
```</p>

<p>好的, 来执行脚本…</p>

<p>得到了如下错误, WTF:</p>

<p><code>
PicklingError: Can't pickle &lt;type 'function'&gt;: attribute lookup __builtin__.function failed
</code></p>

<p>=,= 和 Pickle 有毛关系, 百思不得…</p>

<h2 id="section-1">解答</h2>

<p>这时候先上搜索引擎.</p>

<p>在 SO 上得到了这样一对问答: <a href="http://stackoverflow.com/questions/9336646/python-decorator-with-multiprocessing-fails">戳这里</a></p>

<p>简单总结一下:</p>

<ul>
  <li>进程间通信时, 对象(数据)的传输是需要序列化的.</li>
  <li>Python 中对象序列化最常见的方法是 Pickle</li>
  <li>不是所有的 Python 对象都可以用 Pickle 序列化</li>
  <li>函数装饰器反回的函数对象就不在可 Pickle 对象之列</li>
  <li>换成类装饰器就万事大吉</li>
</ul>

<p>好了, 先来结出类装饰器的版本:</p>

<p>```python
class timer(object):
    def <strong>init</strong>(self, func):
        self.func = func</p>

<pre><code>def __call__(self, *args):
    start = time.time()
    ret = self.func(*args)
    return ret, time.time() - start
</code></pre>

<p>@timer
def get(url):
    return requests.get(url)
```</p>

<h2 id="section-2">分析</h2>

<p>现在, 来分析一下为什么类装饰器就可以序列化, 而函数装饰器就不可以</p>

<p>先来看, 那些对象是可以序列化的. 参考<a href="https://docs.python.org/2/library/pickle.html#what-can-be-pickled-and-unpickle">官方文档</a></p>

<p>把这个问题相关的简单翻译一下:</p>

<ul>
  <li>只含有可 Pickle 元素的<code>元组</code>/<code>列表</code>/<code>集合</code>/<code>字典</code></li>
  <li>在模块顶层定义的<code>函数</code></li>
  <li><code>__dict__</code> 属性或 <code>__getstarte__()</code> 函数的返回可以 Pickle 的<code>实例</code></li>
</ul>

<h4 id="section-3">函数装饰器</h4>

<p><code>python
def timer(func):
    def _wrap(*args):
        # 省略
        return ret
    return _wrap
</code></p>

<p>我们知道, 装饰器实际上是表达式 <code>get = timer(get)</code> 的语法糖.</p>

<p>那么, 被装饰器包裹后的 <code>get</code> 实际上就是 <code>timer</code> 的返回值 =&gt; <code>_wrap</code> 函数.</p>

<p>而这函数定义的位置是在 <code>timer</code> 内部. 并不满足 Pickle 的条件(模块顶层定义).</p>

<p>所以会导致文章开始的那个错误.</p>

<h4 id="section-4">类装饰器</h4>

<p>```python
class timer(object):
    def <strong>init</strong>(self, func):
        self.func = func</p>

<pre><code>def __call__(self, *args):
    # 省略 ```
</code></pre>

<p>在这里, 被装饰器包裹后的 <code>get</code> 就变成了 <code>timer</code> 类的实例.</p>

<p>既然是实例, 再加上我们没有定义 <strong>getstate</strong> 方法, 就直接来看 <strong>dict</strong> 属性</p>

<p>明显的, 这个实例的 <strong>dict</strong> 是字典 <code>{'func': &lt;function get at 0x*****&gt;}</code></p>

<p>字典所包含的元素为原始的 <code>get</code> 函数, 这个函数是定义在模块顶层的.</p>

<p>既然如此, 那么类装饰器的结果自然也就是可 Pickle 了:</p>

<p><code>原 get 可 Pickle</code> =&gt; <code>__dict__ 可 Pickle</code> =&gt; <code>实例可 Pickle</code></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 元类 DEF]]></title>
    <link href="http://blog.loudou.info/blog/2015/01/12/python-yuan-lei-def/"/>
    <updated>2015-01-12T20:13:16+08:00</updated>
    <id>http://blog.loudou.info/blog/2015/01/12/python-yuan-lei-def</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">元类基础</a></li>
  <li><a href="#section-1">2.* 和 3.* 的坑</a>    <ul>
      <li><a href="#section-2">兼容写法</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">元类基础</h2>

<p>Python 中一切事物都是类型的实例. </p>

<p>数值是数字类型的实例, 字符串是字符串类型的实例, 对象是类-类型的实例</p>

<p>同样的, 类(就是那个用 <code>class</code> 关键字创造出来的东西), 也是<em>某种</em>类型的实例</p>

<p>这种类型就叫<code>元类</code>.</p>

<p>如果说类是创建对象的模板, 那么<code>元类</code>就是创建类的模板</p>

<p>下面的代码就创建了一个名为 <code>meta</code> 的元类, 当然, 这个元类什么都没定义</p>

<p><code>python
meta = type('meta', (object,), {})
</code></p>

<p>当然, 元类的定义还有其它方法, 还请自行 <a href="https://mygso.herokuapp.com/search?q=Python+%E5%85%83%E7%B1%BB">Google</a></p>

<h2 id="section-1">2.* 和 3.* 的坑</h2>

<p>因为元类可能复用, 而要创建的类也会有一些自己的属性.</p>

<p>所以我们一般会这么写</p>

<p><code>python
class Cls(object):
    __metaclass__ = meta
    def method_of_cls(self):
        pass
</code></p>

<p>但是这么写有一个问题 – <code>不兼容 3.*</code></p>

<p>在 <code>3.*</code> 中, 元类语法不是上面这个样子</p>

<p>而是:</p>

<p><code>
class Cls(metaclass=meta):
    def method_of_cls(self):
        pass
</code></p>

<p>而且, 两种写法完全不兼容(不像 print)</p>

<h3 id="section-2">兼容写法</h3>

<p>语法上不兼容就没撤了?</p>

<p>如果真要兼容 <code>2.*</code> 和 <code>3.*</code>, 只能放弃 <code>class</code> 关键字, 直接使用 type 的返回值</p>

<p><code>python
Cls = meta
</code></p>

<p>有需要自定义的方法的情况, 将 type 的调用封装一下就可以了.</p>

<p>```python
def meta(name, parents, attrs):
    # do sth with name/parents/attrs
    return type(name, parents, attrs)</p>

<p>Cls = meta(‘Cls1’, (object,), {})</p>

<p>def method_of_cls2(self):
    pass
Clas = meta(‘Cls2’, (object,), {‘method_of_cls2’: method_of_cls2})
```</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 名称空间对性能的影响]]></title>
    <link href="http://blog.loudou.info/blog/2014/11/13/python-ming-cheng-kong-jian-dui-xing-neng-de-ying-xiang/"/>
    <updated>2014-11-13T20:03:05+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/11/13/python-ming-cheng-kong-jian-dui-xing-neng-de-ying-xiang</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">名称空间</a></li>
  <li><a href="#section-1">变量寻址</a></li>
  <li><a href="#section-2">循环优化</a></li>
</ul>

<h2 id="section">名称空间</h2>

<p>Python 中变量的作用域有一个特别的名字叫做<code>名称空间</code></p>

<p><code>名称空间</code>呢, 有以下这些特点:</p>

<ul>
  <li>每一个模块, 函数, 类, 实例, 都拥有一个独立的名称空间.    </li>
  <li>每一个变量都会处在一个名称空间下.     </li>
  <li>名称空间可以相互包含, 或者说有上下级关系</li>
  <li>在下级名称空间中可以访问上级名称空间的变量</li>
</ul>

<p>用代码来举例子:</p>

<p>```python namespace.py
in_module = ‘in module’</p>

<p>def method():
    in_method = ‘in method’
```</p>

<p>在上面这段代码中, 一共有 个名称空间, 分别是:</p>

<ul>
  <li>文件, 就是 <code>namespace.py</code> 里面, 有<code>in_module</code> 变量</li>
  <li>函数, 就是 <code>method</code> 里面, 有<code>in_method</code> 变量</li>
</ul>

<p>以上名称空间, 从上向下都是包含关系.</p>

<h2 id="section-1">变量寻址</h2>

<p>一般来讲, 在一个名称空间中, 只能访问到属于这个名称空间的变量</p>

<p>所以对于上面的代码来讲:</p>

<table>
  <thead>
    <tr>
      <th>名称空间</th>
      <th>可见变量</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>namespace.py</td>
      <td><code>in_module</code></td>
    </tr>
    <tr>
      <td>method</td>
      <td><code>in_method</code></td>
    </tr>
  </tbody>
</table>

<p>同时, 下级名称空间是可以访问到上级名称空间中的变量的.  <br />
于是上表就变成了</p>

<table>
  <thead>
    <tr>
      <th>名称空间</th>
      <th>可见变量</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>namespace.py</td>
      <td><code>in_module</code></td>
    </tr>
    <tr>
      <td>method</td>
      <td><code>in_method</code>, <code>in_module</code></td>
    </tr>
  </tbody>
</table>

<p>所以现在可以在 <code>method</code> 中访问所有 <code>in_*</code> 变量  <br />
就像下面这样</p>

<p><code>python
def method():
    in_method = 'in method'
    print in_method
    print in_module
</code></p>

<p>所谓<code>变量寻址</code>, 指的就是</p>

<blockquote>
  <p>Python 在当前名称空间下找不到变量定义时,
会继续搜索上一层名称空间, 直到顶层.</p>
</blockquote>

<p>这件事了.</p>

<p>概念说了一大堆, 和性能优化好像都没啥关系. 下面就进入正题</p>

<h2 id="section-2">循环优化</h2>

<p>在日常代码编写中, 我们有时会写类似这样的代码:</p>

<p>```python
import math</p>

<p>def foo(lst):
    for i in xrange(len(lst)):
        lst[i] = math.sin(lst[i])
```</p>

<p>上面代码中, <code>foo</code> 里并没有定义 <code>math</code>.
它是通过<code>变量寻址</code>在上一层找到了引入进来的<code>math</code>进行操作</p>

<p>并且, 在循环内部, 每访问一次 <code>math</code> 就会发生一次<code>变量寻址</code>.
这对性能有一定的损耗.</p>

<p>我们可以创建一个<code>foo</code>内部的变量直接指向我们要用的<code>math.sin</code>
然后再进入循环, 这样可以节省不少时间</p>

<p><code>python
def woo(lst):
    sin = math.sin
    for i in xrange(len(lst)):
        lst[i] = sin(lst[i])
</code></p>

<p>当然, 类似这样重复调用外部方法的函数, 我们可以直接用 <code>map</code> 来代替</p>

<p><code>python
def moo(lst):
    return map(math.sin, lst)
</code></p>

<p>下面是用 <code>timeit</code> 模块跑的基准测试结果:</p>

<p><code>
foo: 20.8992490768
woo: 15.5716171265
moo: 12.033983945
</code></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[count += 1 不是原子级的]]></title>
    <link href="http://blog.loudou.info/blog/2014/10/10/count-plus-equals-1-bu-shi-yuan-zi-ji-de/"/>
    <updated>2014-10-10T12:04:09+08:00</updated>
    <id>http://blog.loudou.info/blog/2014/10/10/count-plus-equals-1-bu-shi-yuan-zi-ji-de</id>
    <content type="html"><![CDATA[<!--more-->
<ul id="markdown-toc">
  <li><a href="#section">怀疑</a></li>
  <li><a href="#section-1">测试</a></li>
  <li><a href="#section-2">分析</a></li>
  <li><a href="#section-3">扩展</a></li>
</ul>

<h2 id="section">怀疑</h2>

<p>一直以为 Python 中类似 <code>count += 1</code> 的操作是原子级的…</p>

<p>于是在看到如下代码时, 产生了怀疑</p>

<p><code>python
done_num = 0
lock = threading.RLock()
# 省略...
class Trans(threading.Thread):
    def run(self):
        global count
        # ...
        lock.acquire()
        count += 1
        lock.release()
        # ...
</code></p>

<p>看到这部分代码时, 第一反应是为毛这种统计要用全局变量做啊…  <br />
且不说这种用全局变量的行为; 为毛做个计数 + 1 也要锁一下啊. 难道计数不是原子级的吗!!!</p>

<h2 id="section-1">测试</h2>

<p>本着, <code>如果不出代码出过问题, 不会在这么逗[哔][^1]的地方加锁</code> 的想法. 用以下代码进行了测试.</p>

<p>```python</p>

<p>count = 0</p>

<p>class GlobalCount(threading.Thread):
    def <strong>init</strong>(self):
        super(GlobalCount, self).<strong>init</strong>()</p>

<pre><code>def run(self):
    global count
    for dummy_i in xrange(10):
        count += 1
</code></pre>

<p>threads = []
threads_num = 100000</p>

<p>for dummy_i in xrange(threads_num):
    threads.append(GlobalCount())</p>

<p>for thread in threads:
    thread.start()</p>

<p>for thread in threads:
    thread.join()</p>

<p>print count
```</p>

<p>如果 count += 1 是线程安全的话, 上面这段脚本执行完成后输出应该是 <code>1000000</code>. 不会多, 也不会少</p>

<p>执行以上脚本三次的结果:</p>

<p><code>bash
999990
999982
999940
</code></p>

<p>哇嚓嘞, 还真是线程不安全的…</p>

<h2 id="section-2">分析</h2>

<p>好吧, 即然线程不安全了, 那为什么呢? 为什么做个加法会线程不安全呢?</p>

<p>来看下 <code>count += 1</code> 的编译码:</p>

<p><code>
3 LOAD_CONST               1 (1)
6 INPLACE_ADD
7 STORE_GLOBAL             0 (count)
</code></p>

<p>假设如下场景:  <br />
1. 如果有那个一个线程完成 <code>3 LOAD_CONST</code> 后, 因为时间片消耗完了停了一小会儿. 我们假设这时 count 为 999  <br />
2. 这时候, 其它线程正常进行, 并且 count 已经增加到 1003 或者更大.  <br />
3. <code>1.</code>中的线程又得到的时间片, 完成后续步骤. 这时 count 被改回到 1000.  <br />
4. 其它线程的计数被抹掉了…</p>

<h2 id="section-3">扩展</h2>

<p>类似的在其它语言中 <code>count++</code> 等操作也有不是线程安全的</p>

<p>相关阅读: <a href="https://www.google.com/?gws_rd=ssl#q=i%2B%2B+%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">来自Google</a></p>

<hr />

]]></content>
  </entry>
  
</feed>
